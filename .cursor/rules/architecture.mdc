---
alwaysApply: true
---
# Architecture & Structure Rules - Exam Bank System
## Folder Structure, Naming Conventions, and Organization Patterns

---

## 📁 Backend Structure (Go + gRPC)

### Directory Organization
```
apps/backend/internal/
├── entity/              # Domain models
├── repository/          # Data access (interfaces + implementations)
├── service/             # Business logic (feature-based)
├── grpc/                # gRPC handlers (thin layer)
├── middleware/          # gRPC interceptors
├── config/              # Configuration
└── util/                # Shared utilities
```

### Naming Conventions (Go)
- **Files**: snake_case (`exam_service.go`)
- **Types**: PascalCase (`type ExamService struct {}`)
- **Functions**: PascalCase (exported), camelCase (unexported)
- **Constants**: PascalCase or SCREAMING_SNAKE_CASE

### Layer Pattern (Go)
- **gRPC handlers**: Thin - auth, validation, conversion only
- **Services**: Fat - business logic, coordination
- **Repository**: Data access, query building
- **Entity**: Domain models, database-agnostic

---

## 📁 Frontend Structure (Next.js 14 + TypeScript)

### Directory Organization
```
apps/frontend/src/
├── app/                 # Next.js App Router pages
├── components/
│   ├── features/       # Feature-specific components
│   │   └── exams/
│   │       ├── shared/      # Reusable within feature
│   │       ├── browse/      # Route-specific
│   │       └── create/
│   ├── ui/             # Base UI (Shadcn)
│   ├── layout/         # Layout components
│   └── common/         # Shared across app
├── lib/                # Utilities, helpers, config
├── services/           # API/gRPC clients
├── hooks/              # Custom React hooks (feature-based)
├── types/              # TypeScript definitions
└── contexts/           # React contexts
```

### Naming Conventions (TypeScript/React)
- **Files**: kebab-case (`exam-card.tsx`, `use-exam-data.ts`)
- **Components**: PascalCase (`export function ExamCard()`)
- **Hooks**: camelCase starting with `use` (`useExamData()`)
- **Types/Interfaces**: PascalCase (`interface ExamCardProps {}`)

### Component Structure
```typescript
"use client"; // If client component

// 1. External dependencies
import React from "react";

// 2. Internal modules
import { Button } from "@/components/ui";
import { useExamData } from "@/hooks/exam";

// 3. Types
import type { Exam } from "@/types/exam";

// 4. Component
export function ExamCard({ exam }: { exam: Exam }) {
  // Implementation
}
```

---

## 📁 Mobile Structure (Flutter + Clean Architecture)

### Directory Organization
```
apps/mobile/lib/
├── core/                # DI, network, storage, theme
├── features/            # Feature modules (feature-based)
│   └── auth/
│       ├── data/           # Datasources, models, repositories
│       ├── domain/         # Entities, repository interfaces, usecases
│       └── presentation/   # BLoC, pages, widgets
├── shared/              # Shared models, widgets
└── main.dart
```

### Naming Conventions (Dart)
- **Files**: snake_case (`auth_repository.dart`)
- **Classes**: PascalCase (`class AuthRepository {}`)
- **Variables/Functions**: camelCase (`String userName = "John"`)
- **Constants**: lowerCamelCase or SCREAMING_SNAKE_CASE

### Layer Dependencies
```
Presentation → Domain → Data
     ↓
   BLoC (state management)
```

- **Presentation**: Pages, widgets, BLoC
- **Domain**: Entities, repository interfaces, usecases
- **Data**: Remote/local datasources, repository implementations

---

## 🔄 Cross-Platform Pattern

### gRPC Proto Organization
```
packages/proto/
├── common/              # Shared messages
└── v1/                  # API version 1
    ├── auth_service.proto
    ├── exam_service.proto
    └── question_service.proto
```

### Error Handling
- Go: Custom error types, return errors
- TypeScript: gRPC status codes, throw errors
- Dart: Either<Failure, Success> pattern (dartz package)

---

## ✅ File Placement Checklist

**Before creating new file:**
- [ ] Check if similar functionality exists
- [ ] Follow feature-based organization
- [ ] Use correct naming convention for platform
- [ ] Place in correct layer (presentation/domain/data)
- [ ] Not duplicating existing files

**Before adding new feature:**
- [ ] Create feature folder in appropriate location
- [ ] Set up all necessary layers
- [ ] Define interfaces before implementations
- [ ] Follow dependency injection pattern

---

**Key Principles:**
- ✅ Feature-based over type-based organization
- ✅ Separation of concerns (layers)
- ✅ Consistent naming across platforms
- ✅ Thin handlers/controllers, fat services
- ✅ Interface-driven development
