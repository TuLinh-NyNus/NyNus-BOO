---
alwaysApply: true
---
# Architecture & Structure Rules - Exam Bank System
## Folder Structure, Naming Conventions, and Organization Patterns

## ğŸ¯ Purpose
Ensure consistent, maintainable codebase structure across Go backend, Next.js frontend, and Flutter mobile.

---

## ğŸ“ Backend Structure (Go + gRPC)

### Directory Organization
```
apps/backend/internal/
â”œâ”€â”€ entity/              # Domain entities (database models)
â”œâ”€â”€ repository/          # Data access layer (interfaces + implementations)
â”œâ”€â”€ service/             # Business logic layer
â”‚   â”œâ”€â”€ auth/           # Feature-based organization
â”‚   â”œâ”€â”€ exam/
â”‚   â”œâ”€â”€ question/
â”‚   â””â”€â”€ user/
â”œâ”€â”€ grpc/                # gRPC handlers (thin layer)
â”œâ”€â”€ middleware/          # gRPC interceptors (auth, rate limit, etc.)
â”œâ”€â”€ config/              # Configuration management
â”œâ”€â”€ util/                # Shared utilities
â””â”€â”€ validation/          # Input validation logic
```

### Naming Conventions (Go)
```go
// âœ… Files: snake_case
exam_service.go
question_repository.go
auth_interceptor.go

// âœ… Types: PascalCase
type ExamService struct {}
type QuestionRepository interface {}

// âœ… Functions/Methods: PascalCase (exported), camelCase (unexported)
func CreateExam(ctx context.Context) error {}
func validateInput(data string) bool {}

// âœ… Constants: PascalCase or SCREAMING_SNAKE_CASE
const MaxRetryAttempts = 3
const DEFAULT_PAGE_SIZE = 20
```

### Layer Responsibilities (Go)
```go
// âŒ BAD - Business logic in gRPC handler
func (s *ExamServiceServer) CreateExam(ctx context.Context, req *v1.CreateExamRequest) (*v1.CreateExamResponse, error) {
    // Validate
    if req.Title == "" {
        return nil, status.Error(codes.InvalidArgument, "title required")
    }
    // Create entity
    exam := &entity.Exam{Title: req.Title}
    // Save to DB
    if err := s.db.Create(exam).Error; err != nil {
        return nil, err
    }
    return &v1.CreateExamResponse{Exam: convertToProto(exam)}, nil
}

// âœ… GOOD - Thin gRPC handler, logic in service layer
func (s *ExamServiceServer) CreateExam(ctx context.Context, req *v1.CreateExamRequest) (*v1.CreateExamResponse, error) {
    userID, err := middleware.GetUserIDFromContext(ctx)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, "user not found")
    }
    
    exam, err := s.examService.CreateExam(ctx, userID, req)
    if err != nil {
        return nil, convertToGRPCError(err)
    }
    
    return &v1.CreateExamResponse{Exam: exam}, nil
}
```

### Repository Pattern (Go)
```go
// âœ… Interface in repository/interfaces/
type ExamRepository interface {
    Create(ctx context.Context, exam *entity.Exam) error
    FindByID(ctx context.Context, id uuid.UUID) (*entity.Exam, error)
    Update(ctx context.Context, exam *entity.Exam) error
    Delete(ctx context.Context, id uuid.UUID) error
}

// âœ… Implementation in repository/
type examRepositoryImpl struct {
    db *gorm.DB
}

func NewExamRepository(db *gorm.DB) ExamRepository {
    return &examRepositoryImpl{db: db}
}
```

---

## ğŸ“ Frontend Structure (Next.js 14 + TypeScript)

### Directory Organization
```
apps/frontend/src/
â”œâ”€â”€ app/                        # Next.js 14 App Router
â”‚   â”œâ”€â”€ (routes)/              # Route groups
â”‚   â”œâ”€â”€ api/                   # API routes (if needed)
â”‚   â””â”€â”€ layout.tsx
â”œâ”€â”€ components/                 # React components
â”‚   â”œâ”€â”€ features/              # Feature-specific components
â”‚   â”‚   â”œâ”€â”€ exams/
â”‚   â”‚   â”‚   â”œâ”€â”€ shared/       # Shared within feature
â”‚   â”‚   â”‚   â”œâ”€â”€ browse/       # Route-specific
â”‚   â”‚   â”‚   â””â”€â”€ create/
â”‚   â”‚   â””â”€â”€ questions/
â”‚   â”œâ”€â”€ ui/                    # Base UI components (shadcn)
â”‚   â”œâ”€â”€ layout/                # Layout components (header, footer)
â”‚   â””â”€â”€ common/                # Truly shared components
â”œâ”€â”€ lib/                       # Utilities and helpers
â”‚   â”œâ”€â”€ grpc/                  # gRPC client setup
â”‚   â”œâ”€â”€ utils/                 # Pure utility functions
â”‚   â”œâ”€â”€ constants/             # Constants and configs
â”‚   â””â”€â”€ validation/            # Zod schemas
â”œâ”€â”€ services/                  # API/gRPC service clients
â”‚   â””â”€â”€ grpc/                  # Feature-based gRPC clients
â”œâ”€â”€ hooks/                     # Custom React hooks
â”‚   â”œâ”€â”€ auth/                  # Feature-based organization
â”‚   â”œâ”€â”€ exam/
â”‚   â””â”€â”€ question/
â”œâ”€â”€ types/                     # TypeScript type definitions
â”‚   â”œâ”€â”€ api/                   # API response types
â”‚   â””â”€â”€ common.ts
â”œâ”€â”€ contexts/                  # React contexts
â””â”€â”€ styles/                    # Global styles
```

### Naming Conventions (TypeScript/React)
```typescript
// âœ… Files: kebab-case
exam-card.tsx
question-list.tsx
use-exam-data.ts

// âœ… Components: PascalCase
export function ExamCard() {}
export const QuestionList: React.FC = () => {}

// âœ… Hooks: camelCase starting with "use"
export function useExamData() {}
export const useQuestionFilter = () => {}

// âœ… Types/Interfaces: PascalCase
interface ExamCardProps {}
type QuestionStatus = "active" | "inactive";
```

### Component Organization
```typescript
// âœ… GOOD - Feature-based component structure
components/features/exams/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ exam-card.tsx          # Reusable within exams feature
â”‚   â””â”€â”€ exam-status-badge.tsx
â”œâ”€â”€ browse/
â”‚   â”œâ”€â”€ exam-browser.tsx       # Route-specific component
â”‚   â””â”€â”€ exam-filters.tsx
â””â”€â”€ create/
    â””â”€â”€ exam-form.tsx

// âœ… File structure for complex component
/**
 * Component Header
 * Brief description of what this component does
 * 
 * @author Team Name
 * @created YYYY-MM-DD
 */

"use client"; // If client component

// 1. External dependencies
import React from "react";
import { useRouter } from "next/navigation";

// 2. Internal modules
import { Button } from "@/components/ui";
import { useExamData } from "@/hooks/exam";

// 3. Types
import type { Exam } from "@/types/exam";

// 4. Component implementation
export function ExamCard({ exam }: { exam: Exam }) {
  // ... implementation
}
```

### Service Layer (Frontend)
```typescript
// âœ… services/grpc/exam.service.ts
import { ExamServiceClient } from "@/generated/v1/exam_service_pb_service";
import { CreateExamRequest } from "@/generated/v1/exam_service_pb";

export class ExamService {
  private client: ExamServiceClient;
  
  constructor() {
    this.client = new ExamServiceClient(/* config */);
  }
  
  async createExam(data: CreateExamData): Promise<Exam> {
    const request = new CreateExamRequest();
    // ... setup request
    const response = await this.client.createExam(request);
    return response.toObject();
  }
}

// âœ… Single instance export
export const examService = new ExamService();
```

---

## ğŸ“ Mobile Structure (Flutter + Clean Architecture)

### Directory Organization
```
apps/mobile/lib/
â”œâ”€â”€ core/                      # Core utilities (DI, network, storage)
â”‚   â”œâ”€â”€ di/                   # Dependency injection
â”‚   â”œâ”€â”€ network/              # gRPC client setup
â”‚   â”œâ”€â”€ storage/              # Local storage (Hive, SharedPrefs)
â”‚   â”œâ”€â”€ theme/                # App theming
â”‚   â””â”€â”€ utils/                # Utilities
â”œâ”€â”€ features/                  # Feature modules
â”‚   â””â”€â”€ auth/                 # Example feature
â”‚       â”œâ”€â”€ data/
â”‚       â”‚   â”œâ”€â”€ datasources/  # Remote/Local data sources
â”‚       â”‚   â”œâ”€â”€ models/       # Data models (from proto)
â”‚       â”‚   â””â”€â”€ repositories/ # Repository implementations
â”‚       â”œâ”€â”€ domain/
â”‚       â”‚   â”œâ”€â”€ entities/     # Business entities
â”‚       â”‚   â”œâ”€â”€ repositories/ # Repository interfaces
â”‚       â”‚   â””â”€â”€ usecases/     # Business use cases
â”‚       â””â”€â”€ presentation/
â”‚           â”œâ”€â”€ bloc/         # BLoC state management
â”‚           â”œâ”€â”€ pages/        # Screen widgets
â”‚           â””â”€â”€ widgets/      # UI components
â”œâ”€â”€ shared/                    # Shared across features
â”‚   â”œâ”€â”€ models/
â”‚   â””â”€â”€ widgets/
â””â”€â”€ main.dart
```

### Naming Conventions (Dart)
```dart
// âœ… Files: snake_case
exam_card.dart
question_list_page.dart
auth_repository.dart

// âœ… Classes: PascalCase
class ExamCard extends StatelessWidget {}
class AuthRepository implements IAuthRepository {}

// âœ… Variables/Functions: camelCase
String userName = "John";
Future<void> fetchExams() async {}

// âœ… Constants: lowerCamelCase or SCREAMING_SNAKE_CASE
const double defaultPadding = 16.0;
const int MAX_RETRY_ATTEMPTS = 3;
```

### Clean Architecture Layers (Flutter)
```dart
// âœ… Data Layer - datasources/auth_remote_datasource.dart
abstract class AuthRemoteDataSource {
  Future<LoginResponse> login({required String email, required String password});
}

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  final GrpcClient client;
  
  AuthRemoteDataSourceImpl({required this.client});
  
  @override
  Future<LoginResponse> login({required String email, required String password}) async {
    // gRPC call implementation
  }
}

// âœ… Domain Layer - repositories/auth_repository.dart (interface)
abstract class AuthRepository {
  Future<Either<Failure, User>> login({required String email, required String password});
}

// âœ… Data Layer - repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;
  
  AuthRepositoryImpl({required this.remoteDataSource, required this.localDataSource});
  
  @override
  Future<Either<Failure, User>> login({required String email, required String password}) async {
    try {
      final response = await remoteDataSource.login(email: email, password: password);
      final user = UserModel.fromProto(response.user);
      await localDataSource.saveUser(user);
      return Right(user);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    }
  }
}

// âœ… Domain Layer - usecases/login_usecase.dart
class LoginUseCase {
  final AuthRepository repository;
  
  LoginUseCase(this.repository);
  
  Future<Either<Failure, User>> call({required String email, required String password}) {
    return repository.login(email: email, password: password);
  }
}

// âœ… Presentation Layer - bloc/auth_bloc.dart
class AuthBloc extends Bloc<AuthEvent, AuthState> {
  final LoginUseCase loginUseCase;
  
  AuthBloc({required this.loginUseCase}) : super(AuthInitial()) {
    on<LoginRequested>(_onLoginRequested);
  }
  
  Future<void> _onLoginRequested(LoginRequested event, Emitter<AuthState> emit) async {
    emit(AuthLoading());
    final result = await loginUseCase(email: event.email, password: event.password);
    result.fold(
      (failure) => emit(AuthError(message: failure.message)),
      (user) => emit(AuthAuthenticated(user: user)),
    );
  }
}
```

---

## ğŸ”„ Cross-Platform Consistency

### gRPC Proto Organization
```
packages/proto/
â”œâ”€â”€ common/              # Shared messages (pagination, errors)
â”‚   â”œâ”€â”€ error.proto
â”‚   â””â”€â”€ pagination.proto
â””â”€â”€ v1/                  # API version 1
    â”œâ”€â”€ auth_service.proto
    â”œâ”€â”€ exam_service.proto
    â”œâ”€â”€ question_service.proto
    â””â”€â”€ user_service.proto
```

### Error Handling Pattern (All Platforms)
```go
// Backend (Go)
func (s *ExamService) CreateExam(ctx context.Context, req *CreateExamRequest) (*Exam, error) {
    if err := s.validate(req); err != nil {
        return nil, ErrInvalidInput // Custom error type
    }
    // ... logic
}
```

```typescript
// Frontend (TypeScript)
try {
  const exam = await examService.createExam(data);
} catch (error) {
  if (error.code === grpc.Code.INVALID_ARGUMENT) {
    // Handle validation error
  }
}
```

```dart
// Mobile (Dart)
final result = await loginUseCase(email: email, password: password);
result.fold(
  (failure) => emit(AuthError(message: failure.message)),
  (user) => emit(AuthAuthenticated(user: user)),
);
```

---

## âœ… Checklist: File Organization

### Before Creating New File
- [ ] Check if similar functionality already exists
- [ ] Choose correct layer (presentation/domain/data for Flutter, component/service/hook for React)
- [ ] Follow feature-based organization
- [ ] Use correct naming convention for platform
- [ ] Place in appropriate directory based on scope (shared vs feature-specific)

### Before Adding New Feature
- [ ] Create feature folder in appropriate location
- [ ] Set up necessary layers (Go: entity/repository/service, React: component/hook/service, Flutter: data/domain/presentation)
- [ ] Define interfaces before implementations
- [ ] Add types/entities first, then logic
- [ ] Follow dependency injection pattern

---

**Key Principles:**
- âœ… Feature-based organization over type-based
- âœ… Separation of concerns (presentation/domain/data)
- âœ… Consistent naming across all platforms
- âœ… Thin handlers/controllers, fat services
- âœ… Interface-driven development
