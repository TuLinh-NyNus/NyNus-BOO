"""
LaTeX Image Processor - Streamlit UI
Tool x·ª≠ l√Ω h√¨nh ·∫£nh trong file LaTeX (TikZ v√† existing images)
"""
import streamlit as st
import tempfile
import shutil
import zipfile
from pathlib import Path
from processor import LaTeXImageProcessor
from core.streaming_processor import StreamingLaTeXProcessor, ProgressCallback
from config import STREAMLIT_CONFIG
import os
import time
import json

# ===============================
# FUNCTION DEFINITIONS
# ===============================

def _process_multiple_files(selected_files: list, parallel_mode: bool = False) -> dict:
    """X·ª≠ l√Ω nhi·ªÅu files v·ªõi enhanced error handling v√† progress tracking"""
    
    st.markdown("### üìä Ti·∫øn tr√¨nh x·ª≠ l√Ω nhi·ªÅu files")
    
    # T√πy ch·ªçn s·ª≠ d·ª•ng enhanced processor
    use_enhanced_processor = st.checkbox(
        "üõ°Ô∏è S·ª≠ d·ª•ng Enhanced Processor (kh√¥ng d·ª´ng khi g·∫∑p l·ªói)", 
        value=True,
        help="Enhanced processor s·∫Ω ti·∫øp t·ª•c x·ª≠ l√Ω ngay c·∫£ khi g·∫∑p l·ªói, timeout, ho·∫∑c memory issues"
    )
    
    # T·∫°o overall progress UI
    overall_progress = st.progress(0)
    overall_status = st.empty()
    
    # File status table
    status_container = st.container()
    
    # Stats containers
    stats_container = st.container()
    
    with stats_container:
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            total_tikz_metric = st.metric("T·ªïng TikZ", "0")
        with col2:
            total_images_metric = st.metric("T·ªïng Images", "0")
        with col3:
            total_errors_metric = st.metric("T·ªïng Errors", "0")
        with col4:
            processing_time_metric = st.metric("Th·ªùi gian", "0 min")
    
    # Stop button
    stop_col1, stop_col2, stop_col3 = st.columns([2, 1, 2])
    with stop_col2:
        if st.button("‚èπÔ∏è D·ª´ng x·ª≠ l√Ω", type="secondary"):
            st.session_state['stop_multiple_processing'] = True
    
    # Initialize results
    overall_results = {
        'total_files': len(selected_files),
        'completed_files': 0,
        'total_questions': sum(f.get('question_count', 0) for f in selected_files),
        'total_tikz_compiled': 0,
        'total_images_processed': 0,
        'total_errors': 0,
        'file_results': [],
        'start_time': time.time()
    }
    
    try:
        # Process files based on mode and processor choice
        if use_enhanced_processor:
            # Use enhanced processor with better resilience
            st.info("üõ°Ô∏è **Enhanced Processor** - X·ª≠ l√Ω an to√†n v·ªõi error recovery")
            overall_results = _process_files_with_enhanced_processor(selected_files, overall_results,
                                                                   overall_progress, overall_status, status_container)
        elif parallel_mode:
            # Parallel processing (advanced)
            st.info("‚ö° **Ch·∫ø ƒë·ªô song song** - X·ª≠ l√Ω nhi·ªÅu files c√πng l√∫c")
            overall_results = _process_files_parallel(selected_files, overall_results, 
                                                    overall_progress, overall_status, status_container)
        else:
            # Sequential processing (safe)
            st.info("üîÑ **Ch·∫ø ƒë·ªô t·ª´ng file** - X·ª≠ l√Ω l·∫ßn l∆∞·ª£t")
            overall_results = _process_files_sequential(selected_files, overall_results,
                                                      overall_progress, overall_status, status_container)
        
        # Final summary
        processing_time = time.time() - overall_results['start_time']
        
        st.success("‚úÖ X·ª≠ l√Ω ho√†n t·∫•t t·∫•t c·∫£ files!")
        
        # Update final stats
        with stats_container:
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("T·ªïng TikZ", f"{overall_results['total_tikz_compiled']:,}")
            with col2:
                st.metric("T·ªïng Images", f"{overall_results['total_images_processed']:,}")
            with col3:
                st.metric("T·ªïng Errors", f"{overall_results['total_errors']:,}")
            with col4:
                st.metric("Th·ªùi gian", f"{processing_time/60:.1f} min")
        
        st.balloons()
        
    except Exception as e:
        st.error(f"‚ùå L·ªói x·ª≠ l√Ω: {str(e)}")
        overall_results['error'] = str(e)
    
    # Chu·∫©n h√≥a k·∫øt qu·∫£ cho tab2
    overall_results['tikz_compiled'] = overall_results['total_tikz_compiled']
    overall_results['images_processed'] = overall_results['total_images_processed']
    overall_results['errors'] = overall_results['total_errors']
    
    # T·ªïng h·ª£p questions t·ª´ file_results
    questions = []
    for i, file_result in enumerate(overall_results['file_results']):
        if 'questions' in file_result:
            questions.extend(file_result['questions'])
        else:
            # T·∫°o question placeholder n·∫øu kh√¥ng c√≥ chi ti·∫øt
            questions.append({
                'index': i + 1,
                'subcount': 'N/A',
                'question_tikz': 0,
                'solution_tikz': 0,
                'existing_images': 0,
                'errors': [file_result.get('error', '')] if file_result.get('error') else []
            })
    
    overall_results['questions'] = questions
    
    # Thi·∫øt l·∫≠p output_dir v√† processed_content t·ª´ file ƒë·∫ßu ti√™n
    if overall_results['file_results']:
        first_result = overall_results['file_results'][0]
        if 'output_dir' in first_result:
            overall_results['output_dir'] = first_result['output_dir']
        if 'processed_content' in first_result:
            overall_results['processed_content'] = first_result['processed_content']
        if 'processed_file' in first_result:
            overall_results['processed_file'] = first_result['processed_file']
    
    return overall_results


def _process_files_sequential(selected_files: list, overall_results: dict, 
                            overall_progress, overall_status, status_container) -> dict:
    """X·ª≠ l√Ω files l·∫ßn l∆∞·ª£t v·ªõi enhanced error handling v√† resource management"""
    import time
    import gc
    import traceback
    from concurrent.futures import ThreadPoolExecutor, TimeoutError
    
    successful_files = []
    failed_files = []
    
    for idx, file_info in enumerate(selected_files):
        # Check for stop signal
        if st.session_state.get('stop_multiple_processing', False):
            st.warning(f"‚èπÔ∏è ƒê√£ d·ª´ng x·ª≠ l√Ω t·∫°i file {idx+1}/{len(selected_files)}")
            break
        
        # Update overall progress
        progress = idx / len(selected_files)
        overall_progress.progress(progress)
        overall_status.text(f"üìä X·ª≠ l√Ω file {idx+1}/{len(selected_files)}: {file_info['name']}")
        
        # Display current file status
        with status_container:
            st.info(f"üìÑ ƒêang x·ª≠ l√Ω: **{file_info['name']}** ({file_info.get('question_count', 0):,} c√¢u h·ªèi)")
        
        # Enhanced processing with timeout and error handling
        file_result = _process_single_file_with_timeout(file_info, status_container)
        
        # Update results based on status
        if file_result.get('status') == 'success':
            # Update overall stats
            overall_results['total_tikz_compiled'] += file_result.get('tikz_compiled', 0)
            overall_results['total_images_processed'] += file_result.get('images_processed', 0)
            overall_results['total_errors'] += file_result.get('errors', 0)
            overall_results['completed_files'] += 1
            successful_files.append(file_info['name'])
            
            with status_container:
                st.success(f"‚úÖ Ho√†n th√†nh: {file_info['name']} - TikZ: {file_result.get('tikz_compiled', 0)}, Images: {file_result.get('images_processed', 0)}")
        
        elif file_result.get('status') == 'timeout':
            overall_results['total_errors'] += 1
            failed_files.append(f"{file_info['name']} (timeout)")
            with status_container:
                st.error(f"‚è∞ Timeout: {file_info['name']} - X·ª≠ l√Ω qu√° l√¢u, ƒë√£ b·ªè qua")
        
        else:
            overall_results['total_errors'] += 1
            failed_files.append(f"{file_info['name']} (error)")
            with status_container:
                st.error(f"‚ùå L·ªói: {file_info['name']} - {file_result.get('error', 'Unknown error')}")
        
        # Add to file results
        file_result['file_name'] = file_info['name']
        overall_results['file_results'].append(file_result)
        
        # Memory cleanup after each file
        gc.collect()
        
        # Small delay to prevent overwhelming the system
        time.sleep(0.1)
    
    # Final progress update with summary
    overall_progress.progress(1.0)
    summary = f"‚úÖ Ho√†n th√†nh: {overall_results['completed_files']}/{len(selected_files)} files"
    if failed_files:
        summary += f" | ‚ùå L·ªói: {len(failed_files)} files"
    overall_status.text(summary)
    
    # Display detailed summary
    with status_container:
        if successful_files:
            st.success(f"‚úÖ **Th√†nh c√¥ng ({len(successful_files)} files):** {', '.join(successful_files[:5])}{'...' if len(successful_files) > 5 else ''}")
        if failed_files:
            st.error(f"‚ùå **Th·∫•t b·∫°i ({len(failed_files)} files):** {', '.join(failed_files[:5])}{'...' if len(failed_files) > 5 else ''}")
    
    return overall_results


def _process_single_file_with_timeout(file_info: dict, status_container, timeout_minutes: int = 30) -> dict:
    """X·ª≠ l√Ω m·ªôt file v·ªõi timeout protection v√† enhanced error handling"""
    import concurrent.futures
    import traceback
    
    def _safe_process_file():
        """Wrapper function ƒë·ªÉ x·ª≠ l√Ω file an to√†n"""
        try:
            # Determine processing method based on file size
            if file_info.get('question_count', 0) >= 10000:
                # Large file - use streaming processor
                from core.streaming_processor import StreamingLaTeXProcessor
                processor = StreamingLaTeXProcessor()
                return processor.process_large_file(file_info['path'])
            else:
                # Normal file - use standard processor
                processor = LaTeXImageProcessor()
                return processor.process_file_inplace(file_info['path'], update_original=True)
                
        except Exception as e:
            # Detailed error logging
            error_details = {
                'error': str(e),
                'error_type': type(e).__name__,
                'traceback': traceback.format_exc(),
                'file_path': file_info['path'],
                'status': 'error'
            }
            return error_details
    
    # Run with timeout
    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
        try:
            # Submit task with timeout
            future = executor.submit(_safe_process_file)
            file_result = future.result(timeout=timeout_minutes * 60)  # Convert to seconds
            
            # Check if result contains error
            if 'error' not in file_result:
                file_result['status'] = 'success'
                return file_result
            else:
                file_result['status'] = 'error'
                return file_result
                
        except concurrent.futures.TimeoutError:
            # File processing timed out
            return {
                'status': 'timeout',
                'error': f'File processing timed out after {timeout_minutes} minutes',
                'file_name': file_info['name'],
                'tikz_compiled': 0,
                'images_processed': 0,
                'errors': 1
            }
            
        except Exception as e:
            # Unexpected error
            return {
                'status': 'error',
                'error': f'Unexpected error: {str(e)}',
                'error_type': type(e).__name__,
                'file_name': file_info['name'],
                'tikz_compiled': 0,
                'images_processed': 0,
                'errors': 1
            }


def _process_files_parallel(selected_files: list, overall_results: dict,
                           overall_progress, overall_status, status_container) -> dict:
    """X·ª≠ l√Ω files song song (advanced - c·∫ßn nhi·ªÅu RAM)"""
    from concurrent.futures import ThreadPoolExecutor, as_completed
    import time
    
    max_workers = min(3, len(selected_files))  # Limit concurrent files
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # Submit all files
        future_to_file = {}
        for file_info in selected_files:
            if file_info.get('question_count', 0) >= 10000:
                # Large file
                streaming_processor = StreamingLaTeXProcessor()
                future = executor.submit(streaming_processor.process_large_file, file_info['path'])
            else:
                # Normal file 
                processor = LaTeXImageProcessor()
                future = executor.submit(processor.process_file_inplace, file_info['path'], True)
            
            future_to_file[future] = file_info
        
        # Process completed files
        completed_count = 0
        for future in as_completed(future_to_file):
            if st.session_state.get('stop_multiple_processing', False):
                break
            
            file_info = future_to_file[future]
            completed_count += 1
            
            # Update progress
            progress = completed_count / len(selected_files)
            overall_progress.progress(progress)
            overall_status.text(f"üìä Ho√†n th√†nh {completed_count}/{len(selected_files)} files")
            
            try:
                file_result = future.result()
                
                if 'error' not in file_result:
                    overall_results['total_tikz_compiled'] += file_result.get('tikz_compiled', 0)
                    overall_results['total_images_processed'] += file_result.get('images_processed', 0)
                    overall_results['total_errors'] += file_result.get('errors', 0)
                    overall_results['completed_files'] += 1
                    file_result['status'] = 'success'
                    
                    with status_container:
                        st.success(f"‚úÖ Ho√†n th√†nh: {file_info['name']}")
                else:
                    file_result['status'] = 'error'
                    overall_results['total_errors'] += 1
                    with status_container:
                        st.error(f"‚ùå L·ªói: {file_info['name']} - {file_result['error']}")
                
                file_result['file_name'] = file_info['name']
                overall_results['file_results'].append(file_result)
                
            except Exception as e:
                error_result = {
                    'file_name': file_info['name'],
                    'status': 'error', 
                    'error': str(e)
                }
                overall_results['file_results'].append(error_result)
                overall_results['total_errors'] += 1
                
                with status_container:
                    st.error(f"‚ùå Exception: {file_info['name']} - {str(e)}")
    
    return overall_results


def _process_files_with_enhanced_processor(selected_files: list, overall_results: dict,
                                         overall_progress, overall_status, status_container) -> dict:
    """X·ª≠ l√Ω files v·ªõi Enhanced Processor cho error resilience t·ªëi ƒëa"""
    from core.enhanced_processor import EnhancedLaTeXProcessor
    import time
    
    # Kh·ªüi t·∫°o enhanced processor
    processor = EnhancedLaTeXProcessor(
        max_memory_mb=1500,  # 1.5GB memory threshold
        cleanup_temp=True
    )
    
    # Callback function ƒë·ªÉ c·∫≠p nh·∫≠t progress
    def progress_callback(current_idx, total_files, current_file):
        if st.session_state.get('stop_multiple_processing', False):
            return  # Stop signal
            
        progress = current_idx / total_files
        overall_progress.progress(progress)
        overall_status.text(f"üìä X·ª≠ l√Ω file {current_idx+1}/{total_files}: {current_file}")
        
        with status_container:
            st.info(f"üõ°Ô∏è ƒêang x·ª≠ l√Ω: **{current_file}** ({current_idx+1}/{total_files})")
    
    # X·ª≠ l√Ω batch v·ªõi enhanced processor
    try:
        enhanced_results = processor.process_files_batch(
            file_list=selected_files,
            callback=progress_callback,
            timeout_per_file=30,  # 30 minutes per file
            continue_on_error=True
        )
        
        # Chuy·ªÉn ƒë·ªïi k·∫øt qu·∫£ v·ªÅ format c·∫ßn thi·∫øt
        overall_results['total_tikz_compiled'] = enhanced_results['total_tikz_compiled']
        overall_results['total_images_processed'] = enhanced_results['total_images_processed']
        overall_results['total_errors'] = enhanced_results['total_errors']
        overall_results['completed_files'] = enhanced_results['successful_files']
        overall_results['file_results'] = enhanced_results['file_results']
        
        # Hi·ªÉn th·ªã k·∫øt qu·∫£ chi ti·∫øt
        with status_container:
            if enhanced_results['successful_files'] > 0:
                st.success(
                    f"‚úÖ **Th√†nh c√¥ng:** {enhanced_results['successful_files']}/{enhanced_results['total_files']} files "
                    f"- TikZ: {enhanced_results['total_tikz_compiled']}, Images: {enhanced_results['total_images_processed']}"
                )
            
            if enhanced_results['failed_files'] > 0:
                st.error(
                    f"‚ùå **Th·∫•t b·∫°i:** {enhanced_results['failed_files']} files - "
                    f"Errors: {enhanced_results['total_errors']}"
                )
            
            # Hi·ªÉn th·ªã processing errors n·∫øu c√≥
            if enhanced_results.get('processing_errors'):
                with st.expander("üîç Xem chi ti·∫øt l·ªói x·ª≠ l√Ω"):
                    for error in enhanced_results['processing_errors']:
                        st.error(f"**{error['file']}:** {error['error']}")
        
        # L·∫•y summary t·ª´ processor
        summary = processor.get_processing_summary()
        
        # Log th√¥ng tin ƒë·ªÉ debug
        st.info(f"üìä **T√≥m t·∫Øt Enhanced Processing:**")
        st.info(f"  ‚Ä¢ Th√†nh c√¥ng: {summary['processed_files']} files")
        st.info(f"  ‚Ä¢ Th·∫•t b·∫°i: {summary['failed_files']} files")
        
    except Exception as e:
        st.error(f"‚ùå L·ªói trong Enhanced Processor: {str(e)}")
        overall_results['error'] = f"Enhanced Processor error: {str(e)}"
    
    return overall_results


def _process_large_file(file_path: str, question_count: int) -> dict:
    """X·ª≠ l√Ω file l·ªõn v·ªõi progress tracking"""
    
    # T·∫°o progress UI
    progress_container = st.container()
    
    with progress_container:
        st.markdown("### üìä Ti·∫øn tr√¨nh x·ª≠ l√Ω")
        
        # Progress bar
        progress_bar = st.progress(0)
        
        # Status text
        status_text = st.empty()
        
        # Stats container
        stats_container = st.container()
        
        with stats_container:
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                tikz_metric = st.metric("TikZ Compiled", "0")
            with col2:
                images_metric = st.metric("Images Processed", "0")
            with col3:
                errors_metric = st.metric("Errors", "0")
            with col4:
                memory_metric = st.metric("Memory Usage", "0 MB")
        
        # Stop button
        stop_col1, stop_col2, stop_col3 = st.columns([2, 1, 2])
        with stop_col2:
            if st.button("‚èπÔ∏è D·ª´ng x·ª≠ l√Ω", type="secondary"):
                st.session_state['stop_processing'] = True
    
    # Create progress callback
    progress_callback = ProgressCallback(progress_bar, status_text, stats_container)
    
    # Initialize streaming processor
    streaming_processor = StreamingLaTeXProcessor()
    
    try:
        # Start processing
        results = streaming_processor.process_large_file(file_path, progress_callback)
        
        if 'error' in results:
            st.error(f"‚ùå L·ªói: {results['error']}")
        else:
            # Final update
            progress_bar.progress(1.0)
            status_text.success("‚úÖ X·ª≠ l√Ω ho√†n t·∫•t!")
            
            # Update final metrics
            with stats_container:
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("TikZ Compiled", f"{results.get('tikz_compiled', 0):,}")
                with col2:
                    st.metric("Images Processed", f"{results.get('images_processed', 0):,}")
                with col3:
                    st.metric("Errors", f"{results.get('errors', 0):,}")
                with col4:
                    processing_time = results.get('processing_time', 0)
                    st.metric("Processing Time", f"{processing_time/60:.1f} min")
            
            st.balloons()
    
    except Exception as e:
        st.error(f"‚ùå L·ªói x·ª≠ l√Ω: {str(e)}")
        results = {'error': str(e)}
    
    return results

# ===============================
# HELPER: Persist state and scan files
# ===============================

def _state_dir() -> Path:
    return Path(__file__).parent / "state"

def _state_file() -> Path:
    return _state_dir() / "selection.json"

def load_persisted_state() -> dict:
    try:
        sf = _state_file()
        if sf.exists():
            with open(sf, 'r', encoding='utf-8') as f:
                data = json.load(f)
                if not isinstance(data, dict):
                    raise ValueError("State file invalid")
                data.setdefault('last_dir', str(Path.home()))
                data.setdefault('selected_paths', [])
                return data
    except Exception:
        pass
    return {'last_dir': str(Path.home()), 'selected_paths': []}

def save_persisted_state(state: dict):
    try:
        sd = _state_dir()
        sd.mkdir(parents=True, exist_ok=True)
        with open(_state_file(), 'w', encoding='utf-8') as f:
            json.dump({'last_dir': state.get('last_dir', str(Path.home())),
                       'selected_paths': state.get('selected_paths', [])}, f, ensure_ascii=False, indent=2)
    except Exception:
        # Kh√¥ng ch·∫∑n UI n·∫øu l∆∞u state th·∫•t b·∫°i
        pass

def scan_tex_files(base_dir: str, recursive: bool = True) -> list:
    base = Path(base_dir)
    if not base.exists():
        return []
    try:
        if recursive:
            files = [str(p) for p in base.rglob('*.tex') if p.is_file()]
        else:
            files = [str(p) for p in base.glob('*.tex') if p.is_file()]
        return sorted(files)
    except Exception:
        return []

def pick_tex_files(initial_dir: str | None) -> list:
    """M·ªü h·ªôp tho·∫°i h·ªá ƒëi·ªÅu h√†nh ƒë·ªÉ ch·ªçn nhi·ªÅu file .tex v√† tr·∫£ v·ªÅ danh s√°ch ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi"""
    try:
        # Ch·ªâ ho·∫°t ƒë·ªông t·ªët khi ch·∫°y c·ª•c b·ªô
        import tkinter as tk
        from tkinter import filedialog
        init_dir = initial_dir if initial_dir and Path(initial_dir).exists() else str(Path.home())
        root = tk.Tk()
        root.withdraw()
        # ƒê∆∞a dialog l√™n tr√™n c√πng ƒë·ªÉ d·ªÖ th·∫•y
        try:
            root.attributes('-topmost', True)
        except Exception:
            pass
        file_paths = filedialog.askopenfilenames(
            initialdir=init_dir,
            title='Ch·ªçn file LaTeX',
            filetypes=[('LaTeX files', '*.tex')]
        )
        root.destroy()
        return list(file_paths)
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c h·ªôp tho·∫°i duy·ªát file: {e}")
        return []

def pick_folder(initial_dir: str | None) -> str:
    """M·ªü h·ªôp tho·∫°i h·ªá ƒëi·ªÅu h√†nh ƒë·ªÉ ch·ªçn th∆∞ m·ª•c v√† tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi"""
    try:
        # Ch·ªâ ho·∫°t ƒë·ªông t·ªët khi ch·∫°y c·ª•c b·ªô
        import tkinter as tk
        from tkinter import filedialog
        init_dir = initial_dir if initial_dir and Path(initial_dir).exists() else str(Path.home())
        root = tk.Tk()
        root.withdraw()
        # ƒê∆∞a dialog l√™n tr√™n c√πng ƒë·ªÉ d·ªÖ th·∫•y
        try:
            root.attributes('-topmost', True)
        except Exception:
            pass
        folder_path = filedialog.askdirectory(
            initialdir=init_dir,
            title='Ch·ªçn th∆∞ m·ª•c ch·ª©a file LaTeX'
        )
        root.destroy()
        return folder_path if folder_path else ""
    except Exception as e:
        st.error(f"Kh√¥ng m·ªü ƒë∆∞·ª£c h·ªôp tho·∫°i ch·ªçn th∆∞ m·ª•c: {e}")
        return ""

# ===============================
# STREAMLIT UI SETUP
# ===============================

# Page config
st.set_page_config(
    page_title=STREAMLIT_CONFIG['page_title'],
    page_icon=STREAMLIT_CONFIG['page_icon'],
    layout=STREAMLIT_CONFIG['layout'],
    initial_sidebar_state=STREAMLIT_CONFIG['initial_sidebar_state']
)

# CSS t√πy ch·ªânh
st.markdown("""
<style>
    .main-header {
        text-align: center;
        color: #2E86AB;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    .info-box {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        margin: 10px 0;
    }
    .success-box {
        background-color: #d4edda;
        padding: 15px;
        border-radius: 5px;
        border-left: 5px solid #28a745;
    }
    .error-box {
        background-color: #f8d7da;
        padding: 15px;
        border-radius: 5px;
        border-left: 5px solid #dc3545;
    }
    .warning-box {
        background-color: #fff3cd;
        padding: 15px;
        border-radius: 5px;
        border-left: 5px solid #ffc107;
    }
</style>
""", unsafe_allow_html=True)

# Header
st.markdown("<h1 class='main-header'>üñºÔ∏è LaTeX Image Processor</h1>", unsafe_allow_html=True)
st.markdown("### C√¥ng c·ª• x·ª≠ l√Ω h√¨nh ·∫£nh TikZ v√† chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh trong file LaTeX")

# Sidebar - H∆∞·ªõng d·∫´n
with st.sidebar:
    st.markdown("## üìñ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng")
    
    with st.expander("üéØ M·ª•c ƒë√≠ch"):
        st.markdown("""
        Tool n√†y gi√∫p:
        - Compile code TikZ th√†nh h√¨nh ·∫£nh WEBP
        - Copy v√† rename h√¨nh ·∫£nh c√≥ s·∫µn theo subcount
        - Thay th·∫ø TikZ v√† c·∫≠p nh·∫≠t path h√¨nh trong file .tex
        - T·ªï ch·ª©c h√¨nh ·∫£nh v√†o th∆∞ m·ª•c images/
        """)
    
    with st.expander("üìù Quy t·∫Øc ƒë·∫∑t t√™n"):
        st.markdown("""
        **V·ªõi subcount [XX.N]:**
        - C√¢u h·ªèi: `XXN-QUES.webp`
        - L·ªùi gi·∫£i: `XXN-SOL.webp`
        - Nhi·ªÅu h√¨nh: `XXN-QUES-1.webp`, `XXN-QUES-2.webp`
        
        **Kh√¥ng c√≥ subcount:**
        - Format: `t√™nfile_cauX-TYPE.webp`
        """)
    
    with st.expander("‚öôÔ∏è C·∫•u h√¨nh"):
        st.markdown("""
        - **Compiler:** pdflatex
        - **Format:** WEBP
        - **DPI:** 300
        - **Quality:** 95%
        """)
    
    st.markdown("---")
    st.markdown("### üõ†Ô∏è Y√™u c·∫ßu h·ªá th·ªëng")
    st.markdown("""
    - LaTeX distribution (MiKTeX/TeX Live)
    - Python 3.9+
    - poppler-utils (cho pdf2image)
    """)

# Main content
tab1, tab2, tab3 = st.tabs(["üìÅ Duy·ªát & X·ª≠ l√Ω", "üìä K·∫øt qu·∫£", "‚ÑπÔ∏è Th√¥ng tin"])

with tab1:
    st.markdown("### üìÇ Ch·ªçn file LaTeX ƒë·ªÉ x·ª≠ l√Ω")

    # T·∫£i/Persist state l·ª±a ch·ªçn
    if 'persist_state' not in st.session_state:
        st.session_state['persist_state'] = load_persisted_state()
    state = st.session_state['persist_state']


    st.markdown("#### üóÇÔ∏è Duy·ªát file")
    st.caption(f"Th∆∞ m·ª•c m·∫∑c ƒë·ªãnh: {state.get('last_dir') or str(Path.home())}")

    # T·∫°o 2 columns cho 2 lo·∫°i ch·ªçn
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üìÅ Ch·ªçn file .tex", type="secondary", use_container_width=True):
            picks = pick_tex_files(state.get('last_dir'))
            if picks:
                st.session_state['selected_paths_widget'] = list(picks)
                # C·∫≠p nh·∫≠t last_dir theo file ƒë·∫ßu ti√™n ƒë∆∞·ª£c ch·ªçn
                st.session_state['persist_state']['last_dir'] = str(Path(picks[0]).parent)
                save_persisted_state(st.session_state['persist_state'])
                st.success(f"‚úÖ ƒê√£ ch·ªçn {len(picks)} file(s)")
            else:
                st.info("Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c ch·ªçn")
    
    with col2:
        if st.button("üìÇ Ch·ªçn folder ƒë·ªÉ scan", type="secondary", use_container_width=True):
            folder_path = pick_folder(state.get('last_dir'))
            if folder_path:
                st.session_state['selected_folder'] = folder_path
                # C·∫≠p nh·∫≠t last_dir
                st.session_state['persist_state']['last_dir'] = folder_path
                save_persisted_state(st.session_state['persist_state'])
                st.success(f"‚úÖ ƒê√£ ch·ªçn folder: {Path(folder_path).name}")
            else:
                st.info("Kh√¥ng c√≥ folder n√†o ƒë∆∞·ª£c ch·ªçn")
    
    # Ph·∫ßn scan folder
    if 'selected_folder' in st.session_state and st.session_state['selected_folder']:
        folder_path = st.session_state['selected_folder']
        st.markdown("#### üìÇ Scan files t·ª´ folder")
        st.info(f"üìÅ Folder: `{folder_path}`")
        
        # T√πy ch·ªçn scan
        scan_recursive = st.checkbox("üîÑ Scan ƒë·ªá quy (bao g·ªìm th∆∞ m·ª•c con)", value=True)
        
        col_scan1, col_scan2 = st.columns([1, 1])
        
        with col_scan1:
            if st.button("üîç Scan files .tex", type="primary", use_container_width=True):
                with st.spinner("ƒêang scan files..."):
                    scanned_files = scan_tex_files(folder_path, recursive=scan_recursive)
                    if scanned_files:
                        st.session_state['scanned_files'] = scanned_files
                        st.success(f"‚úÖ T√¨m th·∫•y {len(scanned_files)} file(s) .tex")
                    else:
                        st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file .tex n√†o")
        
        with col_scan2:
            if st.button("üóëÔ∏è X√≥a folder ƒë√£ ch·ªçn", type="secondary", use_container_width=True):
                if 'selected_folder' in st.session_state:
                    del st.session_state['selected_folder']
                if 'scanned_files' in st.session_state:
                    del st.session_state['scanned_files']
                st.rerun()
        
        # Hi·ªÉn th·ªã k·∫øt qu·∫£ scan
        if 'scanned_files' in st.session_state and st.session_state['scanned_files']:
            scanned_files = st.session_state['scanned_files']
            st.markdown(f"##### üìã Danh s√°ch files ƒë∆∞·ª£c t√¨m th·∫•y ({len(scanned_files)} files)")
            
            # T√πy ch·ªçn ch·ªçn t·∫•t c·∫£
            select_all = st.checkbox("‚òëÔ∏è Ch·ªçn t·∫•t c·∫£ files", value=True)
            
            selected_from_scan = []
            
            # Hi·ªÉn th·ªã danh s√°ch v·ªõi checkbox
            for idx, file_path in enumerate(scanned_files):
                file_obj = Path(file_path)
                rel_path = file_obj.relative_to(Path(folder_path)) if file_obj.is_absolute() else file_obj
                
                is_selected = select_all
                if not select_all:
                    is_selected = st.checkbox(
                        f"üìÑ {file_obj.name}", 
                        value=False,
                        key=f"scan_file_{idx}",
                        help=f"ƒê∆∞·ªùng d·∫´n: {rel_path}"
                    )
                else:
                    st.checkbox(
                        f"üìÑ {file_obj.name}", 
                        value=True,
                        key=f"scan_file_{idx}",
                        help=f"ƒê∆∞·ªùng d·∫´n: {rel_path}"
                    )
                
                if is_selected:
                    selected_from_scan.append(file_path)
            
            # Button ƒë·ªÉ th√™m files ƒë√£ ch·ªçn v√†o danh s√°ch x·ª≠ l√Ω
            if selected_from_scan:
                st.info(f"üìä ƒê√£ ch·ªçn: {len(selected_from_scan)} file(s) t·ª´ scan")
                
                col_add1, col_add2, col_add3 = st.columns([1, 2, 1])
                with col_add2:
                    if st.button("‚ûï Th√™m files ƒë√£ ch·ªçn v√†o danh s√°ch x·ª≠ l√Ω", type="primary", use_container_width=True):
                        # Th√™m v√†o selected_paths_widget
                        current_selection = st.session_state.get('selected_paths_widget', [])
                        # Lo·∫°i b·ªè tr√πng l·∫∑p
                        new_files = [f for f in selected_from_scan if f not in current_selection]
                        st.session_state['selected_paths_widget'] = current_selection + new_files
                        st.success(f"‚úÖ ƒê√£ th√™m {len(new_files)} file(s) m·ªõi v√†o danh s√°ch x·ª≠ l√Ω")
                        if len(selected_from_scan) - len(new_files) > 0:
                            st.info(f"‚ÑπÔ∏è {len(selected_from_scan) - len(new_files)} file(s) ƒë√£ c√≥ trong danh s√°ch")

    # Bi√™n d·ªãch selected_files t·ª´ selected_paths v√† th√™m th√¥ng tin source
    selected_files = []
    for p in st.session_state.get('selected_paths_widget', state.get('selected_paths', [])):
        f = Path(p)
        if f.exists() and f.suffix == '.tex':
            # X√°c ƒë·ªãnh source c·ªßa file
            source = 'browse'  # M·∫∑c ƒë·ªãnh l√† browse
            if 'scanned_files' in st.session_state and str(p) in st.session_state['scanned_files']:
                source = 'folder_scan'
            
            selected_files.append({
                'name': f.name,
                'path': str(f),
                'size': f.stat().st_size,
                'source': source
            })

    # Hi·ªÉn th·ªã danh s√°ch file ƒë√£ ch·ªçn
    if selected_files:
        st.markdown("### üìã Danh s√°ch file ƒë√£ ch·ªçn")

        total_size = sum(f['size'] for f in selected_files)
        st.info(f"üìä ƒê√£ ch·ªçn: {len(selected_files)} file(s) - {total_size/1024:.1f} KB")

        for idx, file_info in enumerate(selected_files):
            with st.expander(f"üìÑ {file_info['name']} ({file_info['size']/1024:.1f} KB)", expanded=False):
                col1, col2, col3 = st.columns([2, 1, 1])

                with col1:
                    st.text(f"Path: {file_info['path']}")
                    source_text = "Duy·ªát file" if file_info['source'] == 'browse' else "Scan folder"
                    st.text(f"Source: {source_text}")

                with col2:
                    # Preview button
                    if st.button(f"üëÅÔ∏è Preview", key=f"preview_{idx}"):
                        try:
                            with open(file_info['path'], 'r', encoding='utf-8') as f:
                                content = f.read()
                            st.text_area(
                                f"N·ªôi dung {file_info['name']}",
                                content[:1000] + "..." if len(content) > 1000 else content,
                                height=200,
                                key=f"content_{idx}"
                            )
                        except Exception as e:
                            st.error(f"Kh√¥ng th·ªÉ ƒë·ªçc file: {str(e)}")

                with col3:
                    if st.button(f"üóëÔ∏è X√≥a", key=f"remove_{idx}"):
                        # C·∫≠p nh·∫≠t danh s√°ch ƒë√£ ch·ªçn trong widget v√† persist
                        current_sel = st.session_state.get('selected_paths_widget', [])
                        if file_info['path'] in current_sel:
                            current_sel = [p for p in current_sel if p != file_info['path']]
                            st.session_state['selected_paths_widget'] = current_sel
                        st.rerun()
        # Ph√¢n t√≠ch files ƒë√£ ch·ªçn
        st.markdown("### üìä Ph√¢n t√≠ch files")
        total_questions = 0
        large_files = []
        normal_files = []
        with st.spinner("Ph√¢n t√≠ch files..."):
            for file_info in selected_files:
                try:
                    with open(file_info['path'], 'r', encoding='utf-8') as f:
                        question_count = sum(1 for line in f if '\\begin{ex}' in line)
                    file_info['question_count'] = question_count
                    total_questions += question_count
                    if question_count >= 10000:
                        large_files.append(file_info)
                    else:
                        normal_files.append(file_info)
                except Exception as e:
                    st.error(f"L·ªói ph√¢n t√≠ch file {file_info['name']}: {str(e)}")
                    file_info['question_count'] = 0

        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("T·ªïng files", len(selected_files))
        with col2:
            st.metric("T·ªïng c√¢u h·ªèi", f"{total_questions:,}")
        with col3:
            st.metric("Files l·ªõn", len(large_files))
        with col4:
            st.metric("Files th∆∞·ªùng", len(normal_files))

        if large_files:
            st.warning(f"üìà **{len(large_files)} file(s) l·ªõn** ph√°t hi·ªán - S·∫Ω d√πng ch·∫ø ƒë·ªô t·ªëi ∆∞u")
            for file_info in large_files:
                st.info(f"  ‚Ä¢ {file_info['name']}: {file_info['question_count']:,} c√¢u h·ªèi")
        if normal_files:
            st.info(f"üìÑ **{len(normal_files)} file(s) th∆∞·ªùng** - Ch·∫ø ƒë·ªô chu·∫©n")
            for file_info in normal_files:
                st.info(f"  ‚Ä¢ {file_info['name']}: {file_info['question_count']:,} c√¢u h·ªèi")

        estimated_time = total_questions * 2 / 60  # 2 gi√¢y/c√¢u trung b√¨nh
        st.info(f"‚è±Ô∏è **∆Ø·ªõc t√≠nh th·ªùi gian x·ª≠ l√Ω**: {estimated_time:.1f} ph√∫t")

        # Processing section
        st.markdown("### üöÄ X·ª≠ l√Ω Files")
        processing_mode = st.radio(
            "Ch·∫ø ƒë·ªô x·ª≠ l√Ω:",
            ["T·ª´ng file m·ªôt (üîÑ T·ª´ng file)", "Song song (‚ö° Nhanh h∆°n)"],
            help="T·ª´ng file: √≠t t√†i nguy√™n nh∆∞ng ch·∫≠m h∆°n. Song song: nhanh h∆°n nh∆∞ng c·∫ßn nhi·ªÅu RAM"
        )

        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            if st.button("üöÄ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω t·∫•t c·∫£ files", type="primary", use_container_width=True):
                # L∆∞u persist l·ª±a ch·ªçn hi·ªán t·∫°i (last_dir ƒë√£ l∆∞u khi ch·ªçn file)
                st.session_state['persist_state']['selected_paths'] = st.session_state.get('selected_paths_widget', [])
                save_persisted_state(st.session_state['persist_state'])

                parallel_mode = "Song song" in processing_mode
                st.success(f"üöÄ Kh·ªüi ƒë·ªông x·ª≠ l√Ω {len(selected_files)} file(s) - {'Song song' if parallel_mode else 'T·ª´ng file'}!")

                results = _process_multiple_files(selected_files, parallel_mode)

                processed_content = results.get('processed_content')
                if processed_content:
                    st.session_state['processed_content'] = processed_content
                    st.session_state['original_filename'] = 'processed_files.tex'
                    if 'backup_path' in results:
                        st.session_state['backup_info'] = f"File backup t·∫°i: {results['backup_path']}"
                    else:
                        st.session_state['backup_info'] = "Backup ƒë√£ ƒë∆∞·ª£c t·∫°o"
                elif not results.get('error'):
                    st.warning("‚ö†Ô∏è File kh√¥ng c√≥ thay ƒë·ªïi ho·∫∑c kh√¥ng th·ªÉ x·ª≠ l√Ω")
                st.session_state['results'] = results
                st.session_state['processed'] = True
                st.success("‚úÖ X·ª≠ l√Ω ho√†n t·∫•t!")
                st.balloons()

with tab2:
    if 'results' in st.session_state and st.session_state.get('processed'):
        results = st.session_state['results']
        
        if 'error' in results:
            st.error(f"‚ùå L·ªói: {results['error']}")
        else:
            st.markdown("### üìä K·∫øt qu·∫£ x·ª≠ l√Ω")
            
            # Th·ªëng k√™ t·ªïng quan
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("üìù T·ªïng c√¢u h·ªèi", results['total_questions'])
            with col2:
                st.metric("üé® TikZ ƒë√£ compile", results['tikz_compiled'])
            with col3:
                st.metric("üñºÔ∏è H√¨nh ƒë√£ x·ª≠ l√Ω", results['images_processed'])
            with col4:
                st.metric("‚ö†Ô∏è L·ªói", results['errors'])
            
            # Chi ti·∫øt t·ª´ng c√¢u
            with st.expander("üìã Chi ti·∫øt t·ª´ng c√¢u h·ªèi"):
                for q in results['questions']:
                    col1, col2, col3 = st.columns([1, 2, 3])
                    with col1:
                        st.write(f"**C√¢u {q['index']}**")
                    with col2:
                        st.write(f"Subcount: {q.get('subcount', 'N/A')}")
                    with col3:
                        stats = []
                        if q['question_tikz'] > 0:
                            stats.append(f"TikZ c√¢u h·ªèi: {q['question_tikz']}")
                        if q['solution_tikz'] > 0:
                            stats.append(f"TikZ l·ªùi gi·∫£i: {q['solution_tikz']}")
                        if q['existing_images'] > 0:
                            stats.append(f"H√¨nh c√≥ s·∫µn: {q['existing_images']}")
                        st.write(" | ".join(stats) if stats else "Kh√¥ng c√≥ h√¨nh")
                    
                    if q.get('errors'):
                        st.error(f"L·ªói: {', '.join(q['errors'])}")
            
            # Download section
            st.markdown("### üíæ T·∫£i xu·ªëng k·∫øt qu·∫£")
            
            output_dir = Path(results['output_dir'])
            
            col1, col2 = st.columns(2)
            
            with col1:
                # T·∫°o zip file
                zip_path = output_dir.parent / f"{output_dir.name}.zip"
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in output_dir.rglob('*'):
                        if file_path.is_file():
                            arcname = file_path.relative_to(output_dir.parent)
                            zipf.write(file_path, arcname)
                
                # Download button
                with open(zip_path, 'rb') as f:
                    st.download_button(
                        label="üì¶ T·∫£i xu·ªëng t·∫•t c·∫£ (ZIP)",
                        data=f.read(),
                        file_name=f"{output_dir.name}.zip",
                        mime="application/zip",
                        use_container_width=True
                    )
            
            with col2:
                # Download processed .tex file
                if 'processed_content' in st.session_state and 'original_filename' in st.session_state:
                    st.download_button(
                        label="üìÑ T·∫£i file .tex ƒë√£ x·ª≠ l√Ω",
                        data=st.session_state['processed_content'].encode('utf-8'),
                        file_name=st.session_state['original_filename'],
                        mime="text/plain",
                        use_container_width=True
                    )
                else:
                    # Fallback n·∫øu kh√¥ng c√≥ processed_content
                    processed_tex = Path(results['processed_file'])
                    if processed_tex.exists():
                        with open(processed_tex, 'rb') as f:
                            st.download_button(
                                label="üìÑ T·∫£i file .tex ƒë√£ x·ª≠ l√Ω",
                                data=f.read(),
                                file_name=processed_tex.name,
                                mime="text/plain",
                                use_container_width=True
                            )
            
            # Hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n output
            st.info(f"üìÅ K·∫øt qu·∫£ ƒë∆∞·ª£c l∆∞u t·∫°i: `{output_dir}`")
            
            # Hi·ªÉn th·ªã th√¥ng tin backup n·∫øu c√≥
            if 'backup_info' in st.session_state:
                st.success(f"üíæ {st.session_state['backup_info']}")
    else:
        st.info("üëÜ Vui l√≤ng upload v√† x·ª≠ l√Ω file tr∆∞·ªõc")

with tab3:
    st.markdown("### ‚ÑπÔ∏è Th√¥ng tin v·ªÅ tool")
    
    st.markdown("""
    #### üéØ Ch·ª©c nƒÉng ch√≠nh:
    1. **Parse file LaTeX** ƒë·ªÉ t√¨m c√°c block `\\begin{ex}...\\end{ex}`
    2. **Tr√≠ch xu·∫•t subcount** d·∫°ng `[XX.N]` t·ª´ m·ªói c√¢u h·ªèi
    3. **Compile TikZ** th√†nh h√¨nh ·∫£nh WEBP ch·∫•t l∆∞·ª£ng cao
    4. **X·ª≠ l√Ω h√¨nh c√≥ s·∫µn**: copy v√† rename theo quy t·∫Øc
    5. **C·∫≠p nh·∫≠t file .tex** v·ªõi ƒë∆∞·ªùng d·∫´n h√¨nh m·ªõi
    6. **T·∫°o b√°o c√°o** chi ti·∫øt v·ªÅ qu√° tr√¨nh x·ª≠ l√Ω
    
    #### üîß C√¥ng ngh·ªá s·ª≠ d·ª•ng:
    - **Python 3.9+** v·ªõi Streamlit framework
    - **pdflatex** ƒë·ªÉ compile LaTeX
    - **pdf2image** & **Pillow** ƒë·ªÉ x·ª≠ l√Ω h√¨nh ·∫£nh
    - **regex** ƒë·ªÉ parse LaTeX ph·ª©c t·∫°p
    
    #### üìù L∆∞u √Ω:
    - File g·ªëc s·∫Ω ƒë∆∞·ª£c backup v·ªõi prefix `GOC-`
    - N·∫øu compile TikZ th·∫•t b·∫°i, code TikZ s·∫Ω ƒë∆∞·ª£c gi·ªØ nguy√™n
    - H√¨nh ·∫£nh output c√≥ format WEBP v·ªõi ch·∫•t l∆∞·ª£ng 95%
    - Th∆∞ m·ª•c output c√≥ c√πng t√™n v·ªõi file .tex
    
    #### üë®‚Äçüíª Ph√°t tri·ªÉn b·ªüi:
    H·ªá th·ªëng NyNus - LaTeX Question Bank
    """)
    
    # System check
    st.markdown("### üîç Ki·ªÉm tra h·ªá th·ªëng")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Check LaTeX
        import subprocess
        try:
            result = subprocess.run(['pdflatex', '--version'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                st.success("‚úÖ pdflatex ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t")
            else:
                st.error("‚ùå pdflatex ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t")
        except:
            st.error("‚ùå Kh√¥ng t√¨m th·∫•y pdflatex")
    
    with col2:
        # Check poppler
        try:
            from pdf2image import convert_from_path
            st.success("‚úÖ pdf2image v√† poppler ho·∫°t ƒë·ªông")
        except:
            st.error("‚ùå C·∫ßn c√†i ƒë·∫∑t poppler-utils")

# Footer
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #888;'>
    <small>LaTeX Image Processor v1.0.0 | ¬© 2025 NyNus System</small>
</div>
""", unsafe_allow_html=True)
