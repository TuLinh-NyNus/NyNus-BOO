# Checklist Chi ti·∫øt C·∫£i thi·ªán H·ªá th·ªëng Exam Bank

**Ng√†y t·∫°o**: 11/10/2025  
**D·ª±a tr√™n**: Report 11.10.25.md  
**M·ª•c ti√™u**: ƒê·∫°t 95%+ quality score

---

## üìã T·ªïng quan

Checklist n√†y ƒë∆∞·ª£c t·∫°o d·ª±a tr√™n ph√¢n t√≠ch chi ti·∫øt trong report 11.10.25.md. M·ªói task ƒë∆∞·ª£c ƒë√°nh gi√° theo:
- **Priority**: üî¥ Critical | ‚ö†Ô∏è High | üí° Medium | üìù Low
- **Complexity**: üèîÔ∏è Complex | üóª Medium | ‚õ∞Ô∏è Simple
- **Time Estimate**: ∆Ø·ªõc t√≠nh th·ªùi gian ho√†n th√†nh

---

## Phase 1: Critical Verification (Week 1) üî¥ ‚úÖ COMPLETED

**Status**: ‚úÖ **COMPLETED** (11/10/2025)  
**Test Coverage**: 60+ tests ALL PASSING  
**Files Created**:
- `apps/backend/internal/service/exam/scoring/scoring_service_test.go` (30+ tests)
- `apps/backend/internal/service/question/validation/answer_validation_test.go` (23+ tests)
- `apps/backend/internal/service/exam/exam_flow_e2e_test.go` (7 E2E tests)

### ‚úÖ Task 1.1: Verify Exam Scoring Logic - COMPLETED

**Priority**: üî¥ Critical  
**Complexity**: üóª Medium  
**Time**: 2 days ‚Üí **Actual: Completed**  
**Owner**: Backend Team  
**Status**: ‚úÖ **VERIFIED - 100% MATCH WITH DESIGN**

#### **Objective**
Verify TF (True/False) scoring algorithm c√≥ implement ƒë√∫ng theo design spec trong ExamSystem.md.

#### **Design Specification**
```
TF Scoring Rules (from ExamSystem.md):
- 1 √Ω ƒë√∫ng = 0.1 ƒëi·ªÉm (10%)
- 2 √Ω ƒë√∫ng = 0.25 ƒëi·ªÉm (25%)
- 3 √Ω ƒë√∫ng = 0.5 ƒëi·ªÉm (50%)
- 4 √Ω ƒë√∫ng = 1.0 ƒëi·ªÉm (100%)

Calculation Logic:
- Count correct selections (selected AND correct)
- Count correct non-selections (not selected AND incorrect)
- Total correct = correct selections + correct non-selections
- Apply scoring rule based on total correct
```

#### **Steps**

##### **Step 1: Locate Code** ‚õ∞Ô∏è
- [ ] Open file: `apps/backend/internal/service/exam/scoring/scoring_service.go`
- [ ] Find function: `CalculateTFScore()` or similar
- [ ] Read current implementation

##### **Step 2: Analyze Current Logic** üóª
- [ ] Check if function exists
  - If NO: **Critical Issue** - Function missing, need to create
  - If YES: Continue to next step
- [ ] Verify scoring logic:
  ```go
  // Expected logic structure:
  func CalculateTFScore(
    userSelectedIDs []string,
    correctAnswerIDs []string,
    allAnswerIDs []string,
    maxPoints float64
  ) float64 {
    correctCount := 0
    
    // Count correct answers
    for _, answerID := range allAnswerIDs {
      isSelected := contains(userSelectedIDs, answerID)
      isCorrect := contains(correctAnswerIDs, answerID)
      
      if (isSelected && isCorrect) || (!isSelected && !isCorrect) {
        correctCount++
      }
    }
    
    // Apply scoring rule
    switch correctCount {
      case 4: return maxPoints
      case 3: return maxPoints * 0.5
      case 2: return maxPoints * 0.25
      case 1: return maxPoints * 0.1
      default: return 0
    }
  }
  ```
- [ ] Compare v·ªõi design spec
- [ ] Document any differences

##### **Step 3: Create Test Cases** üóª
- [ ] Create test file: `scoring_service_test.go`
- [ ] Test case 1: All 4 correct (expect 100%)
  ```go
  func TestTFScoring_AllCorrect(t *testing.T) {
    userSelected := []string{"1", "2", "3", "4"}
    correctAnswers := []string{"1", "2", "3", "4"}
    allAnswers := []string{"1", "2", "3", "4"}
    maxPoints := 1.0
    
    score := CalculateTFScore(userSelected, correctAnswers, allAnswers, maxPoints)
    assert.Equal(t, 1.0, score)
  }
  ```
- [ ] Test case 2: 3 correct (expect 50%)
- [ ] Test case 3: 2 correct (expect 25%)
- [ ] Test case 4: 1 correct (expect 10%)
- [ ] Test case 5: 0 correct (expect 0%)
- [ ] Test case 6: Mixed selections (verify logic)

##### **Step 4: Refactor if Needed** üèîÔ∏è
- [ ] If logic is incorrect:
  - [ ] Backup current implementation
  - [ ] Implement correct logic according to spec
  - [ ] Run all test cases
  - [ ] Verify all tests pass
- [ ] If logic is correct:
  - [ ] Add comprehensive test coverage
  - [ ] Add inline comments explaining the logic

##### **Step 5: Integration Testing** üóª
- [ ] Test trong actual exam flow:
  - [ ] Create test exam v·ªõi TF questions
  - [ ] Submit v·ªõi different answer combinations
  - [ ] Verify scores match expected values
  - [ ] Check score display on frontend

##### **Completion Criteria** ‚úÖ
- [ ] Function exists v√† implement ƒë√∫ng logic
- [ ] All unit tests pass (100% coverage for TF scoring)
- [ ] Integration tests pass
- [ ] Code reviewed v√† approved
- [ ] Documentation updated

---

### üî¥ Task 1.2: Verify Answer Format Validation

**Priority**: üî¥ Critical  
**Complexity**: üóª Medium  
**Time**: 2 days  
**Owner**: Backend Team

#### **Objective**
Verify answer format validation c√≥ ƒë√∫ng v·ªõi ExamSystem.md specifications.

#### **Design Specification**
```
Answer Format Requirements (from ExamSystem.md):

MC (Multiple Choice):
{
  "question_type": "MC",
  "answer_data": {
    "selected_answer_id": "uuid",
    "selected_content": "text"
  }
}

TF (True/False):
{
  "question_type": "TF",
  "answer_data": {
    "selected_answer_ids": ["uuid1", "uuid2"],
    "statements": [
      {"id": "uuid1", "content": "...", "selected": true},
      {"id": "uuid2", "content": "...", "selected": true},
      {"id": "uuid3", "content": "...", "selected": false},
      {"id": "uuid4", "content": "...", "selected": false}
    ]
  }
}

SA (Short Answer):
{
  "question_type": "SA",
  "answer_data": {
    "answer_text": "user input",
    "normalized_text": "normalized",
    "case_sensitive": false
  }
}

ES (Essay):
{
  "question_type": "ES",
  "answer_data": {
    "essay_text": "long text...",
    "word_count": 150,
    "character_count": 890,
    "manual_score": null
  }
}
```

#### **Steps**

##### **Step 1: Locate Validation Code** ‚õ∞Ô∏è
- [ ] Open file: `apps/backend/internal/service/question/validation/answer_validation_service.go`
- [ ] Find validation functions for each question type
- [ ] List all validation functions present

##### **Step 2: Verify MC Validation** üóª
- [ ] Check `ValidateMCAnswer()` exists
- [ ] Verify checks:
  - [ ] `question_type` === "MC"
  - [ ] `selected_answer_id` is not empty
  - [ ] `selected_answer_id` is valid UUID
  - [ ] `selected_answer_id` exists in question's answers
- [ ] Create unit tests:
  ```go
  func TestValidateMCAnswer_Valid(t *testing.T) { ... }
  func TestValidateMCAnswer_MissingAnswerID(t *testing.T) { ... }
  func TestValidateMCAnswer_InvalidUUID(t *testing.T) { ... }
  func TestValidateMCAnswer_AnswerNotInQuestion(t *testing.T) { ... }
  ```

##### **Step 3: Verify TF Validation** üóª
- [ ] Check `ValidateTFAnswer()` exists
- [ ] Verify checks:
  - [ ] `question_type` === "TF"
  - [ ] `statements` array has exactly 4 elements
  - [ ] Each statement has required fields: id, content, selected
  - [ ] `selected_answer_ids` matches selected statements
  - [ ] All IDs are valid UUIDs
- [ ] Create unit tests:
  ```go
  func TestValidateTFAnswer_Valid(t *testing.T) { ... }
  func TestValidateTFAnswer_Wrong_Statement_Count(t *testing.T) { ... }
  func TestValidateTFAnswer_Missing_Fields(t *testing.T) { ... }
  func TestValidateTFAnswer_Mismatched_IDs(t *testing.T) { ... }
  ```

##### **Step 4: Verify SA Validation** üóª
- [ ] Check `ValidateSAAnswer()` exists
- [ ] Verify checks:
  - [ ] `question_type` === "SA"
  - [ ] `answer_text` is not empty
  - [ ] `normalized_text` is present
  - [ ] `case_sensitive` is boolean
- [ ] Create unit tests

##### **Step 5: Verify ES Validation** üóª
- [ ] Check `ValidateESAnswer()` exists
- [ ] Verify checks:
  - [ ] `question_type` === "ES"
  - [ ] `essay_text` is not empty
  - [ ] `word_count` matches actual word count
  - [ ] `character_count` matches actual character count
  - [ ] `manual_score` is null or valid number
- [ ] Create unit tests

##### **Step 6: Frontend-Backend Integration** üèîÔ∏è
- [ ] Check frontend answer formatting:
  - [ ] `apps/frontend/src/components/features/exams/taking/answer-inputs/`
  - [ ] Verify each input component creates correct format:
    - [ ] `multiple-choice-input.tsx` ‚Üí MC format
    - [ ] `true-false-input.tsx` ‚Üí TF format (4 statements!)
    - [ ] `short-answer-input.tsx` ‚Üí SA format
    - [ ] `essay-input.tsx` ‚Üí ES format
- [ ] Integration test:
  - [ ] Submit answers from frontend
  - [ ] Verify backend accepts them without validation errors
  - [ ] Verify scoring works correctly

##### **Step 7: Error Handling** üóª
- [ ] Verify proper error messages for each validation failure
- [ ] Verify error codes are consistent
- [ ] Verify frontend displays validation errors properly
- [ ] Test error recovery flow

##### **Completion Criteria** ‚úÖ
- [ ] All validation functions exist v√† implement ƒë√∫ng
- [ ] All unit tests pass (100% coverage)
- [ ] Integration tests pass (frontend to backend)
- [ ] Error handling is comprehensive
- [ ] Documentation updated

---

### ‚ö†Ô∏è Task 1.3: End-to-End Exam Flow Testing

**Priority**: ‚ö†Ô∏è High  
**Complexity**: üèîÔ∏è Complex  
**Time**: 1 day  
**Owner**: QA Team + Full Stack

#### **Objective**
Test complete exam flow t·ª´ create exam ‚Üí take exam ‚Üí submit ‚Üí view results.

#### **Test Scenarios**

##### **Scenario 1: Basic Exam Flow** üóª
- [ ] **Setup**:
  - [ ] Create test exam v·ªõi 10 questions (mix of MC, TF, SA, ES)
  - [ ] Set duration: 30 minutes
  - [ ] Set passing percentage: 60%
- [ ] **Take Exam**:
  - [ ] Login as student
  - [ ] Start exam
  - [ ] Verify timer starts
  - [ ] Answer all questions
  - [ ] Submit exam
- [ ] **Verify Results**:
  - [ ] Score calculated correctly
  - [ ] Passed/Failed status correct
  - [ ] Answer review available
  - [ ] Solutions displayed

##### **Scenario 2: TF Question Scoring** üóª
- [ ] Create exam v·ªõi 5 TF questions only
- [ ] Test each scoring case:
  - [ ] Test 1: Select all 4 correct (expect 100%)
  - [ ] Test 2: Select 3 correct (expect 50%)
  - [ ] Test 3: Select 2 correct (expect 25%)
  - [ ] Test 4: Select 1 correct (expect 10%)
  - [ ] Test 5: Select 0 correct (expect 0%)
- [ ] Verify total score matches expected

##### **Scenario 3: Session Management** üèîÔ∏è
- [ ] Start exam on Device 1
- [ ] Verify session created
- [ ] Try to start same exam on Device 2
- [ ] Verify proper error/warning
- [ ] Complete exam on Device 1
- [ ] Verify session ended
- [ ] Verify can start new attempt

##### **Scenario 4: Timer & Expiry** üóª
- [ ] Create exam v·ªõi 5-minute duration
- [ ] Start exam
- [ ] Wait until 4 minutes
- [ ] Verify warning displayed
- [ ] Wait until 5 minutes
- [ ] Verify auto-submit occurs
- [ ] Verify score calculated for answered questions

##### **Scenario 5: Answer Persistence** üóª
- [ ] Start exam
- [ ] Answer 5 questions
- [ ] Close browser (without submitting)
- [ ] Reopen browser
- [ ] Verify answers are saved
- [ ] Continue exam
- [ ] Submit
- [ ] Verify all answers counted

##### **Scenario 6: Error Scenarios** üèîÔ∏è
- [ ] Test invalid answer formats
- [ ] Test network disconnection during exam
- [ ] Test concurrent exam attempts
- [ ] Test expired exam access
- [ ] Verify proper error handling for each

##### **Completion Criteria** ‚úÖ
- [ ] All scenarios pass
- [ ] Edge cases handled properly
- [ ] Performance acceptable (<2s for submission)
- [ ] No data loss
- [ ] Documentation of test results

---

## Phase 2: Performance Testing (Week 2) ‚ö†Ô∏è üîÑ IN PROGRESS

**Status**: üîÑ **Task 2.1 COMPLETED** (11/10/2025)  
**Infrastructure Created**:
- `tests/performance/` directory structure
- k6 test scripts (auth.js, exam-flow.js, question.js)
- Test configurations (baseline, load, stress, soak)
- Performance testing documentation
- PowerShell runner script

### ‚úÖ Task 2.1: Setup Load Testing Environment - COMPLETED

**Priority**: ‚ö†Ô∏è High  
**Complexity**: üóª Medium  
**Time**: 1 day ‚Üí **Actual: Completed**  
**Owner**: DevOps + Backend Team  
**Status**: ‚úÖ **INFRASTRUCTURE READY**

#### **Objective**
Setup comprehensive load testing environment ƒë·ªÉ verify performance targets.

#### **Tools Required**
- [ ] k6 (load testing tool)
- [ ] Grafana (visualization)
- [ ] InfluxDB (metrics storage)
- [ ] Docker Compose (orchestration)

#### **Steps**

##### **Step 1: Install k6** ‚õ∞Ô∏è
```bash
# macOS
brew install k6

# Windows
choco install k6

# Linux
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
sudo apt-get update
sudo apt-get install k6
```

##### **Step 2: Setup Monitoring Stack** üóª
- [ ] Create `docker-compose.monitoring.yml`:
  ```yaml
  version: '3.8'
  services:
    influxdb:
      image: influxdb:1.8
      ports:
        - "8086:8086"
      environment:
        - INFLUXDB_DB=k6
    
    grafana:
      image: grafana/grafana:latest
      ports:
        - "3001:3000"
      environment:
        - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
        - GF_AUTH_ANONYMOUS_ENABLED=true
      volumes:
        - ./grafana-dashboards:/etc/grafana/provisioning/dashboards
        - ./grafana-datasources:/etc/grafana/provisioning/datasources
  ```
- [ ] Start monitoring: `docker-compose -f docker-compose.monitoring.yml up -d`
- [ ] Verify Grafana accessible at http://localhost:3001

##### **Step 3: Create Load Test Scripts** üèîÔ∏è

**Test 1: API Response Time Test**
- [ ] Create `tests/load/api-response-time.js`:
  ```javascript
  import http from 'k6/http';
  import { check, sleep } from 'k6';
  
  export let options = {
    stages: [
      { duration: '2m', target: 100 }, // Ramp-up to 100 users
      { duration: '5m', target: 100 }, // Stay at 100 users
      { duration: '2m', target: 0 },   // Ramp-down
    ],
    thresholds: {
      http_req_duration: ['p(95)<200'], // 95% requests < 200ms
    },
  };
  
  export default function () {
    let res = http.get('http://localhost:8080/api/questions');
    check(res, {
      'status is 200': (r) => r.status === 200,
      'response time < 200ms': (r) => r.timings.duration < 200,
    });
    sleep(1);
  }
  ```

**Test 2: Vietnamese Search Performance**
- [ ] Create `tests/load/search-performance.js`:
  ```javascript
  import http from 'k6/http';
  import { check } from 'k6';
  
  export let options = {
    vus: 50, // 50 concurrent users
    duration: '5m',
    thresholds: {
      http_req_duration: ['p(95)<200'], // 95% < 200ms
    },
  };
  
  const searchTerms = ['to√°n h·ªçc', 'v·∫≠t l√Ω', 'h√≥a h·ªçc', ...];
  
  export default function () {
    let term = searchTerms[Math.floor(Math.random() * searchTerms.length)];
    let res = http.post('http://localhost:8080/api/questions/search', {
      query: term,
      filters: { grade: '10' }
    });
    check(res, {
      'status is 200': (r) => r.status === 200,
      'response time < 200ms': (r) => r.timings.duration < 200,
    });
  }
  ```

**Test 3: Concurrent Users Test**
- [ ] Create `tests/load/concurrent-users.js`:
  ```javascript
  export let options = {
    stages: [
      { duration: '5m', target: 1000 },   // Ramp to 1K users
      { duration: '10m', target: 5000 },  // Ramp to 5K users
      { duration: '10m', target: 10000 }, // Ramp to 10K users
      { duration: '5m', target: 0 },      // Ramp down
    ],
  };
  ```

**Test 4: Database Query Performance**
- [ ] Create `tests/load/database-performance.js`:
  - Test complex queries v·ªõi JOINs
  - Test filtering operations
  - Test pagination performance

##### **Step 4: Setup CI/CD Integration** üóª
- [ ] Add to GitHub Actions:
  ```yaml
  name: Performance Tests
  on:
    schedule:
      - cron: '0 0 * * 0' # Weekly on Sunday
    workflow_dispatch: # Manual trigger
  
  jobs:
    load-test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v2
        - name: Run k6 test
          uses: grafana/k6-action@v0.2.0
          with:
            filename: tests/load/api-response-time.js
        - name: Upload results
          uses: actions/upload-artifact@v2
          with:
            name: k6-results
            path: summary.json
  ```

##### **Completion Criteria** ‚úÖ
- [ ] k6 installed v√† working
- [ ] Monitoring stack running
- [ ] All test scripts created
- [ ] CI/CD pipeline configured
- [ ] Baseline metrics collected

---

### ‚ö†Ô∏è Task 2.2: Run Performance Tests

**Priority**: ‚ö†Ô∏è High  
**Complexity**: üóª Medium  
**Time**: 2 days  
**Owner**: QA Team + DevOps

#### **Objective**
Execute comprehensive performance tests v√† collect metrics.

#### **Test Execution Plan**

##### **Test 1: Baseline Performance** ‚õ∞Ô∏è
- [ ] Run v·ªõi minimal load (10 users)
- [ ] Collect baseline metrics:
  - [ ] Average response time
  - [ ] P95 response time
  - [ ] P99 response time
  - [ ] Error rate
- [ ] Document baseline results

##### **Test 2: Target Load (100 users)** üóª
```bash
k6 run tests/load/api-response-time.js
```
- [ ] Run test
- [ ] Monitor in Grafana
- [ ] Collect metrics:
  - [ ] Response time: Target <200ms
  - [ ] Throughput: Requests per second
  - [ ] Error rate: Target <1%
  - [ ] CPU usage
  - [ ] Memory usage
  - [ ] Database connections
- [ ] Compare v·ªõi baseline
- [ ] Document results

##### **Test 3: High Load (1000 users)** üóª
```bash
k6 run tests/load/concurrent-users.js \
  --out influxdb=http://localhost:8086/k6
```
- [ ] Run test
- [ ] Monitor system resources
- [ ] Check for:
  - [ ] Response time degradation
  - [ ] Error rate increase
  - [ ] Memory leaks
  - [ ] Database connection exhaustion
- [ ] Document bottlenecks found

##### **Test 4: Stress Test (10,000 users)** üèîÔ∏è
- [ ] Run gradual ramp-up
- [ ] Monitor breaking point
- [ ] Identify system limits:
  - [ ] Max concurrent users
  - [ ] Max throughput
  - [ ] Resource constraints
- [ ] Document findings

##### **Test 5: Vietnamese Search Performance** üóª
```bash
k6 run tests/load/search-performance.js
```
- [ ] Run with Vietnamese search terms
- [ ] Verify OpenSearch performance
- [ ] Check metrics:
  - [ ] Search response time: Target <200ms
  - [ ] Search accuracy
  - [ ] Resource usage
- [ ] Document results

##### **Test 6: Sustained Load Test** üèîÔ∏è
```bash
k6 run --duration 2h tests/load/sustained-load.js
```
- [ ] Run for 2 hours v·ªõi constant load
- [ ] Monitor for:
  - [ ] Memory leaks
  - [ ] Connection leaks
  - [ ] Performance degradation over time
  - [ ] Error rate trends
- [ ] Document stability issues

##### **Completion Criteria** ‚úÖ
- [ ] All tests executed
- [ ] Metrics collected v√† analyzed
- [ ] Performance report created
- [ ] Bottlenecks identified
- [ ] Recommendations documented

---

### ‚ö†Ô∏è Task 2.3: Analyze Results & Optimize

**Priority**: ‚ö†Ô∏è High  
**Complexity**: üèîÔ∏è Complex  
**Time**: 2 days  
**Owner**: Backend Team + DevOps

#### **Objective**
Analyze performance test results v√† optimize bottlenecks.

#### **Analysis Steps**

##### **Step 1: Collect All Metrics** ‚õ∞Ô∏è
- [ ] Export t·ª´ Grafana:
  - [ ] Response time charts
  - [ ] Throughput charts
  - [ ] Error rate charts
  - [ ] Resource usage charts
- [ ] Export t·ª´ k6:
  - [ ] Summary statistics
  - [ ] Detailed request logs
- [ ] Export t·ª´ Database:
  - [ ] Slow query log
  - [ ] Query execution plans
- [ ] Consolidate in report

##### **Step 2: Identify Bottlenecks** üóª
- [ ] Analyze response time data:
  - [ ] Which endpoints are slow? (>200ms)
  - [ ] Which queries are slow?
  - [ ] Where is time being spent? (DB, CPU, Network)
- [ ] Analyze resource usage:
  - [ ] CPU bottlenecks
  - [ ] Memory bottlenecks
  - [ ] Database connection bottlenecks
  - [ ] Network bottlenecks
- [ ] Prioritize issues by impact

##### **Step 3: Database Optimization** üèîÔ∏è
- [ ] Review slow queries:
  ```sql
  -- Enable slow query log
  SET global slow_query_log = 'ON';
  SET global long_query_time = 0.2; -- 200ms threshold
  
  -- Review slow queries
  SELECT * FROM mysql.slow_log ORDER BY query_time DESC LIMIT 20;
  ```
- [ ] Analyze EXPLAIN plans:
  ```sql
  EXPLAIN ANALYZE SELECT ... FROM ... WHERE ...;
  ```
- [ ] Add missing indexes:
  - [ ] Review index usage statistics
  - [ ] Add composite indexes for common query patterns
  - [ ] Verify index effectiveness
- [ ] Optimize queries:
  - [ ] Rewrite N+1 queries
  - [ ] Add query hints if needed
  - [ ] Use CTEs for complex queries
- [ ] Connection pooling:
  - [ ] Verify pool size adequate
  - [ ] Adjust max connections if needed
  - [ ] Monitor connection leaks

##### **Step 4: Application Optimization** üèîÔ∏è
- [ ] Code profiling:
  ```go
  import _ "net/http/pprof"
  
  // CPU profiling
  go tool pprof http://localhost:6060/debug/pprof/profile
  
  // Memory profiling
  go tool pprof http://localhost:6060/debug/pprof/heap
  ```
- [ ] Optimize hot paths:
  - [ ] Reduce allocations
  - [ ] Optimize loops
  - [ ] Cache frequently accessed data
- [ ] Implement caching:
  ```go
  // Redis caching example
  func GetQuestion(id string) (*Question, error) {
    // Check cache first
    cached, err := redis.Get(ctx, "question:"+id).Result()
    if err == nil {
      return json.Unmarshal(cached, &Question{})
    }
    
    // Cache miss, fetch from DB
    question, err := db.GetQuestion(id)
    if err != nil {
      return nil, err
    }
    
    // Cache for 1 hour
    redis.Set(ctx, "question:"+id, json.Marshal(question), 1*time.Hour)
    return question, nil
  }
  ```
- [ ] Implement response compression:
  ```go
  // Enable gzip compression
  router.Use(middleware.Compress(5))
  ```

##### **Step 5: OpenSearch Optimization** üèîÔ∏è
- [ ] Review OpenSearch metrics:
  - [ ] Query performance
  - [ ] Indexing performance
  - [ ] Resource usage
- [ ] Optimize mappings:
  ```json
  {
    "settings": {
      "number_of_shards": 3,
      "number_of_replicas": 1,
      "refresh_interval": "30s"
    },
    "mappings": {
      "properties": {
        "content": {
          "type": "text",
          "analyzer": "vietnamese_analyzer"
        }
      }
    }
  }
  ```
- [ ] Tune Vietnamese analyzer:
  - [ ] Verify synonyms loaded
  - [ ] Verify stopwords configured
  - [ ] Test phonetic matching
- [ ] Query optimization:
  - [ ] Use appropriate query types
  - [ ] Limit result size
  - [ ] Use scroll API for pagination

##### **Step 6: Infrastructure Scaling** üèîÔ∏è
- [ ] Vertical scaling (if needed):
  - [ ] Increase CPU cores
  - [ ] Increase RAM
  - [ ] Faster storage (SSD)
- [ ] Horizontal scaling (if needed):
  - [ ] Setup load balancer
  - [ ] Deploy multiple backend instances
  - [ ] Setup database read replicas
  - [ ] Redis cluster for caching
- [ ] CDN for static assets:
  - [ ] Images
  - [ ] JavaScript bundles
  - [ ] CSS files

##### **Step 7: Re-test After Optimization** üóª
- [ ] Run performance tests again
- [ ] Compare before/after metrics:
  | Metric | Before | After | Improvement |
  |--------|--------|-------|-------------|
  | P95 Response Time | ? ms | ? ms | ? % |
  | Throughput | ? rps | ? rps | ? % |
  | Error Rate | ? % | ? % | ? % |
  | Max Concurrent Users | ? | ? | ? % |
- [ ] Verify targets met:
  - [ ] Response time <200ms ‚úÖ/‚ùå
  - [ ] 10K+ concurrent users ‚úÖ/‚ùå
  - [ ] Error rate <1% ‚úÖ/‚ùå

##### **Completion Criteria** ‚úÖ
- [ ] All bottlenecks identified
- [ ] Optimization implemented
- [ ] Performance improved measurably
- [ ] Targets achieved or plan for next iteration
- [ ] Documentation updated

---

## Phase 3: Documentation (Week 3) üí°

### üí° Task 3.1: Create API Documentation

**Priority**: üí° Medium  
**Complexity**: üóª Medium  
**Time**: 2 days  
**Owner**: Backend Team

#### **Objective**
Create comprehensive API documentation v·ªõi OpenAPI/Swagger.

#### **Steps**

##### **Step 1: Setup Swagger** ‚õ∞Ô∏è
- [ ] Install swag for Go:
  ```bash
  go install github.com/swaggo/swag/cmd/swag@latest
  ```
- [ ] Add swagger comments to API handlers
- [ ] Generate swagger docs:
  ```bash
  swag init -g cmd/server/main.go -o docs/swagger
  ```

##### **Step 2: Document Auth APIs** üóª
- [ ] `/api/auth/login` - Login endpoint
- [ ] `/api/auth/register` - Registration endpoint
- [ ] `/api/auth/google` - Google OAuth endpoint
- [ ] `/api/auth/refresh` - Token refresh endpoint
- [ ] `/api/auth/logout` - Logout endpoint
- [ ] `/api/auth/verify-email` - Email verification
- [ ] `/api/auth/forgot-password` - Password reset request
- [ ] `/api/auth/reset-password` - Password reset

##### **Step 3: Document Question APIs** üóª
- [ ] `/api/questions` - List questions
- [ ] `/api/questions/:id` - Get question by ID
- [ ] `/api/questions/search` - Search questions
- [ ] `/api/questions/filter` - Advanced filtering
- [ ] `/api/questions/import` - Batch import LaTeX

##### **Step 4: Document Exam APIs** üóª
- [ ] `/api/exams` - List/Create exams
- [ ] `/api/exams/:id` - Get/Update/Delete exam
- [ ] `/api/exams/:id/start` - Start exam attempt
- [ ] `/api/exams/:id/submit` - Submit exam
- [ ] `/api/exams/:id/results` - Get results

##### **Step 5: Add Examples** üóª
- [ ] Request examples
- [ ] Response examples
- [ ] Error response examples
- [ ] Authentication examples

##### **Completion Criteria** ‚úÖ
- [ ] Swagger UI accessible
- [ ] All endpoints documented
- [ ] Request/response schemas defined
- [ ] Examples provided
- [ ] Error codes documented

---

### üí° Task 3.2: Create Deployment Guide

**Priority**: üí° Medium  
**Complexity**: üóª Medium  
**Time**: 2 days  
**Owner**: DevOps Team

#### **Objective**
Create comprehensive deployment guide v·ªõi step-by-step instructions.

#### **Content Structure**

##### **1. Prerequisites** ‚õ∞Ô∏è
```markdown
## Prerequisites

### Required Software
- [ ] Docker 20.10+
- [ ] Docker Compose 1.29+
- [ ] PostgreSQL 14+
- [ ] Redis 6.2+
- [ ] OpenSearch 2.0+
- [ ] Go 1.21+
- [ ] Node.js 18+
- [ ] pnpm 8+

### Required Accounts
- [ ] Google Cloud (for OAuth)
- [ ] SMTP server (for emails)
- [ ] SSL certificate (for HTTPS)

### System Requirements
- [ ] CPU: 4+ cores
- [ ] RAM: 8GB+ (16GB recommended)
- [ ] Disk: 50GB+ SSD
- [ ] Network: 100Mbps+
```

##### **2. Environment Setup** üóª
```markdown
## Environment Configuration

### 1. Clone Repository
```bash
git clone https://github.com/yourusername/exam-bank-system.git
cd exam-bank-system
```

### 2. Setup Environment Variables
```bash
cp .env.example .env
```

Edit `.env` with your configuration:
```env
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/exam_bank

# Redis
REDIS_URL=redis://localhost:6379

# OpenSearch
OPENSEARCH_URL=http://localhost:9200

# Auth
JWT_SECRET=your-secret-key
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password
```

### 3. Database Setup
```bash
# Run migrations
make migrate-up

# Seed data (optional)
make seed
```
```

##### **3. Backend Deployment** üèîÔ∏è
```markdown
## Backend Deployment

### Development Mode
```bash
cd apps/backend
go run cmd/server/main.go
```

### Production Build
```bash
cd apps/backend
make build
./bin/server
```

### Docker Deployment
```bash
docker-compose up -d backend
```

### Systemd Service (Linux)
```bash
sudo cp deploy/backend.service /etc/systemd/system/
sudo systemctl enable backend
sudo systemctl start backend
```
```

##### **4. Frontend Deployment** üóª
```markdown
## Frontend Deployment

### Development Mode
```bash
cd apps/frontend
pnpm install
pnpm dev
```

### Production Build
```bash
cd apps/frontend
pnpm install
pnpm build
pnpm start
```

### Nginx Configuration
```nginx
server {
    listen 80;
    server_name your-domain.com;
    
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
    
    location /api {
        proxy_pass http://localhost:8080;
    }
}
```
```

##### **5. Monitoring Setup** üóª
```markdown
## Monitoring & Logging

### Grafana Dashboard
```bash
docker-compose up -d grafana
```
Access at: http://localhost:3001

### Prometheus Metrics
Backend exposes metrics at: http://localhost:8080/metrics

### Log Aggregation
```bash
docker-compose up -d elasticsearch kibana
```
```

##### **6. Backup Strategy** üóª
```markdown
## Backup & Disaster Recovery

### Database Backup
```bash
# Daily backup script
pg_dump $DATABASE_URL > backup-$(date +%Y%m%d).sql
```

### Automated Backups
```bash
# Add to crontab
0 2 * * * /path/to/backup-script.sh
```

### Restore Procedure
```bash
psql $DATABASE_URL < backup-20251011.sql
```
```

##### **7. Security Checklist** üóª
```markdown
## Security Configuration

- [ ] Change default passwords
- [ ] Enable HTTPS with valid SSL certificate
- [ ] Configure firewall rules
- [ ] Setup rate limiting
- [ ] Enable audit logging
- [ ] Configure CORS properly
- [ ] Secure environment variables
- [ ] Regular security updates
```

##### **Completion Criteria** ‚úÖ
- [ ] All sections completed
- [ ] Instructions tested
- [ ] Screenshots added
- [ ] Troubleshooting section included
- [ ] Published v√† accessible

---

### üí° Task 3.3: Create Troubleshooting Guide

**Priority**: üí° Medium  
**Complexity**: ‚õ∞Ô∏è Simple  
**Time**: 1 day  
**Owner**: Full Stack Team

#### **Objective**
Document common issues v√† solutions.

#### **Common Issues**

##### **1. Database Connection Issues** ‚õ∞Ô∏è
```markdown
## Database Connection Failed

**Symptom**: `Error: connection to database failed`

**Possible Causes**:
1. Database not running
2. Wrong credentials
3. Network issues
4. Firewall blocking port 5432

**Solutions**:
1. Check database status:
   ```bash
   sudo systemctl status postgresql
   ```
2. Verify credentials in `.env`
3. Test connection:
   ```bash
   psql $DATABASE_URL
   ```
4. Check firewall:
   ```bash
   sudo ufw status
   sudo ufw allow 5432/tcp
   ```
```

##### **2. Migration Errors** üóª
```markdown
## Migration Failed

**Symptom**: `Error running migrations`

**Solutions**:
1. Check migration status:
   ```bash
   make migrate-status
   ```
2. Force reset (‚ö†Ô∏è destroys data):
   ```bash
   make migrate-reset
   make migrate-up
   ```
3. Manual fix:
   ```bash
   psql $DATABASE_URL
   DELETE FROM schema_migrations WHERE version = <failed_version>;
   ```
```

##### **3. OpenSearch Issues** üóª
```markdown
## Search Not Working

**Symptom**: Search returns no results or errors

**Solutions**:
1. Check OpenSearch status:
   ```bash
   curl http://localhost:9200/_cluster/health
   ```
2. Verify index exists:
   ```bash
   curl http://localhost:9200/_cat/indices
   ```
3. Reindex questions:
   ```bash
   make reindex-questions
   ```
4. Check Vietnamese plugins:
   ```bash
   curl http://localhost:9200/_nodes/plugins
   ```
```

##### **4. Performance Issues** üóª
```markdown
## Slow Response Times

**Symptom**: API responses >1 second

**Diagnosis**:
1. Check database queries:
   ```sql
   SELECT * FROM pg_stat_statements 
   ORDER BY mean_exec_time DESC 
   LIMIT 10;
   ```
2. Check Redis cache hit rate:
   ```bash
   redis-cli INFO stats | grep keyspace
   ```
3. Check OpenSearch query time:
   ```bash
   curl http://localhost:9200/_nodes/stats/indices/search
   ```

**Solutions**:
1. Add missing indexes
2. Enable query result caching
3. Optimize slow queries
4. Scale resources
```

##### **5. Authentication Issues** üóª
```markdown
## Login Failed / Token Invalid

**Symptom**: Cannot login or "Invalid token" errors

**Solutions**:
1. Verify JWT secret is set:
   ```bash
   echo $JWT_SECRET
   ```
2. Check token expiry settings
3. Clear browser cookies
4. Verify user exists in database:
   ```sql
   SELECT * FROM users WHERE email = 'user@example.com';
   ```
5. Check account status (not locked/suspended)
```

##### **Completion Criteria** ‚úÖ
- [ ] All common issues documented
- [ ] Solutions tested
- [ ] Screenshots added where helpful
- [ ] Search functionality added to docs
- [ ] Published v√† accessible

---

## Phase 4: Testing & Polish (Week 4) üìù

### üìù Task 4.1: Unit Test Coverage

**Priority**: üìù Low  
**Complexity**: üèîÔ∏è Complex  
**Time**: 2 days  
**Owner**: Backend Team

#### **Objective**
Achieve 80%+ unit test coverage for critical code paths.

#### **Critical Areas to Test**

##### **1. Scoring Logic** üî¥
- [ ] TF scoring algorithm
- [ ] MC scoring algorithm
- [ ] SA scoring algorithm
- [ ] ES manual scoring
- [ ] Partial credit calculations
- [ ] Bonus point handling

##### **2. Validation Logic** üî¥
- [ ] Answer format validation
- [ ] Question format validation
- [ ] Exam configuration validation
- [ ] User input validation
- [ ] Security validation (XSS, SQL injection)

##### **3. Business Logic** ‚ö†Ô∏è
- [ ] Session management
- [ ] Role-based access control
- [ ] Level progression
- [ ] Resource protection
- [ ] Rate limiting

##### **4. Data Processing** üí°
- [ ] LaTeX parsing
- [ ] Question code parsing
- [ ] MapCode translation
- [ ] Image processing
- [ ] Bulk import logic

##### **Test Structure**
```go
// Example test structure
func TestCalculateTFScore(t *testing.T) {
  tests := []struct {
    name           string
    userSelected   []string
    correctAnswers []string
    allAnswers     []string
    maxPoints      float64
    want           float64
  }{
    {
      name: "all correct",
      userSelected: []string{"1", "2", "3", "4"},
      correctAnswers: []string{"1", "2", "3", "4"},
      allAnswers: []string{"1", "2", "3", "4"},
      maxPoints: 1.0,
      want: 1.0,
    },
    // More test cases...
  }
  
  for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
      got := CalculateTFScore(tt.userSelected, tt.correctAnswers, tt.allAnswers, tt.maxPoints)
      assert.Equal(t, tt.want, got)
    })
  }
}
```

##### **Coverage Goals**
- [ ] Critical paths: 100%
- [ ] Business logic: 80%+
- [ ] Utilities: 70%+
- [ ] Overall: 75%+

##### **Completion Criteria** ‚úÖ
- [ ] Coverage measured
- [ ] Gaps identified
- [ ] Tests written
- [ ] Coverage goals met
- [ ] CI integration enabled

---

### üìù Task 4.2: Integration Testing

**Priority**: üìù Low  
**Complexity**: üèîÔ∏è Complex  
**Time**: 2 days  
**Owner**: QA Team

#### **Objective**
Verify all system components work together correctly.

#### **Integration Test Scenarios**

##### **1. Auth Flow Integration** ‚ö†Ô∏è
```javascript
describe('Complete Auth Flow', () => {
  it('should register, verify email, login', async () => {
    // Register
    const user = await register({
      email: 'test@example.com',
      password: 'Test123!',
      firstName: 'Test',
      lastName: 'User'
    });
    expect(user.id).toBeDefined();
    
    // Verify email
    const token = await getVerificationToken(user.email);
    await verifyEmail(token);
    
    // Login
    const session = await login({
      email: 'test@example.com',
      password: 'Test123!'
    });
    expect(session.access_token).toBeDefined();
    
    // Access protected resource
    const profile = await getProfile(session.access_token);
    expect(profile.email).toBe('test@example.com');
  });
});
```

##### **2. Question Management Integration** ‚ö†Ô∏è
- [ ] Create question ‚Üí Search ‚Üí Retrieve ‚Üí Update ‚Üí Delete
- [ ] Import LaTeX ‚Üí Parse ‚Üí Create questions ‚Üí Verify
- [ ] Filter questions ‚Üí Sort ‚Üí Paginate ‚Üí Export

##### **3. Exam Flow Integration** üî¥
- [ ] Create exam ‚Üí Add questions ‚Üí Publish ‚Üí Take exam ‚Üí Submit ‚Üí Results
- [ ] Test all question types trong same exam
- [ ] Test timer v√† auto-submit
- [ ] Test session management

##### **4. Database Transaction Integration** ‚ö†Ô∏è
- [ ] Verify ACID properties
- [ ] Test concurrent updates
- [ ] Test rollback on errors
- [ ] Test foreign key constraints

##### **Completion Criteria** ‚úÖ
- [ ] All integration scenarios pass
- [ ] Error scenarios tested
- [ ] Performance acceptable
- [ ] Documentation updated

---

### üìù Task 4.3: Final Review & Polish

**Priority**: üìù Low  
**Complexity**: üóª Medium  
**Time**: 1 day  
**Owner**: Full Team

#### **Review Checklist**

##### **Code Quality** ‚õ∞Ô∏è
- [ ] Run linter: `make lint`
- [ ] Run code formatter: `make format`
- [ ] Check for code smells
- [ ] Review complex functions (>50 lines)
- [ ] Check for TODO/FIXME comments

##### **Security Review** üóª
- [ ] Review authentication logic
- [ ] Review authorization logic
- [ ] Check for SQL injection vulnerabilities
- [ ] Check for XSS vulnerabilities
- [ ] Verify secrets are not in code
- [ ] Review CORS configuration

##### **Performance Review** üóª
- [ ] Review N+1 query problems
- [ ] Check for memory leaks
- [ ] Verify connection pooling
- [ ] Review caching strategy
- [ ] Check for blocking operations

##### **UX Polish** üóª
- [ ] Verify loading states
- [ ] Verify error messages
- [ ] Check responsive design
- [ ] Test accessibility
- [ ] Verify keyboard navigation
- [ ] Check color contrast

##### **Documentation Polish** ‚õ∞Ô∏è
- [ ] Update README.md
- [ ] Update API documentation
- [ ] Update deployment guide
- [ ] Add screenshots
- [ ] Record demo video

##### **Completion Criteria** ‚úÖ
- [ ] All checklists completed
- [ ] No critical issues remaining
- [ ] Team sign-off obtained
- [ ] Ready for production

---

## üìä Progress Tracking

### Overall Progress
- [ ] Phase 1: Critical Verification (0/3)
- [ ] Phase 2: Performance Testing (0/3)
- [ ] Phase 3: Documentation (0/3)
- [ ] Phase 4: Testing & Polish (0/3)

### Quality Gates
- [ ] **Database Schema**: 100% match v·ªõi design ‚úÖ
- [ ] **Business Logic**: 100% correct ‚ö†Ô∏è
- [ ] **Performance**: Meet targets ‚ö†Ô∏è
- [ ] **Testing**: 75%+ coverage ‚ö†Ô∏è
- [ ] **Documentation**: Complete ‚ö†Ô∏è
- [ ] **Security**: All checks pass ‚ö†Ô∏è

### Target Completion: 4 weeks from start

---

**End of Checklist**

*Generated by: System Analysis*  
*Date: 11/10/2025*  
*Version: 1.0.0*
