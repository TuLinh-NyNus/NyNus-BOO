// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: v1/mapcode.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MapCodeService_CreateVersion_FullMethodName          = "/v1.MapCodeService/CreateVersion"
	MapCodeService_GetVersions_FullMethodName            = "/v1.MapCodeService/GetVersions"
	MapCodeService_GetActiveVersion_FullMethodName       = "/v1.MapCodeService/GetActiveVersion"
	MapCodeService_SetActiveVersion_FullMethodName       = "/v1.MapCodeService/SetActiveVersion"
	MapCodeService_DeleteVersion_FullMethodName          = "/v1.MapCodeService/DeleteVersion"
	MapCodeService_TranslateCode_FullMethodName          = "/v1.MapCodeService/TranslateCode"
	MapCodeService_TranslateCodes_FullMethodName         = "/v1.MapCodeService/TranslateCodes"
	MapCodeService_GetHierarchyNavigation_FullMethodName = "/v1.MapCodeService/GetHierarchyNavigation"
	MapCodeService_GetStorageInfo_FullMethodName         = "/v1.MapCodeService/GetStorageInfo"
	MapCodeService_GetMapCodeConfig_FullMethodName       = "/v1.MapCodeService/GetMapCodeConfig"
)

// MapCodeServiceClient is the client API for MapCodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MapCode Management Service
type MapCodeServiceClient interface {
	// Version Management
	CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...grpc.CallOption) (*CreateVersionResponse, error)
	GetVersions(ctx context.Context, in *GetVersionsRequest, opts ...grpc.CallOption) (*GetVersionsResponse, error)
	GetActiveVersion(ctx context.Context, in *GetActiveVersionRequest, opts ...grpc.CallOption) (*GetActiveVersionResponse, error)
	SetActiveVersion(ctx context.Context, in *SetActiveVersionRequest, opts ...grpc.CallOption) (*SetActiveVersionResponse, error)
	DeleteVersion(ctx context.Context, in *DeleteVersionRequest, opts ...grpc.CallOption) (*DeleteVersionResponse, error)
	// Translation Services
	TranslateCode(ctx context.Context, in *TranslateCodeRequest, opts ...grpc.CallOption) (*TranslateCodeResponse, error)
	TranslateCodes(ctx context.Context, in *TranslateCodesRequest, opts ...grpc.CallOption) (*TranslateCodesResponse, error)
	GetHierarchyNavigation(ctx context.Context, in *GetHierarchyNavigationRequest, opts ...grpc.CallOption) (*GetHierarchyNavigationResponse, error)
	// Storage Management
	GetStorageInfo(ctx context.Context, in *GetStorageInfoRequest, opts ...grpc.CallOption) (*GetStorageInfoResponse, error)
	// Configuration Access
	GetMapCodeConfig(ctx context.Context, in *GetMapCodeConfigRequest, opts ...grpc.CallOption) (*GetMapCodeConfigResponse, error)
}

type mapCodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMapCodeServiceClient(cc grpc.ClientConnInterface) MapCodeServiceClient {
	return &mapCodeServiceClient{cc}
}

func (c *mapCodeServiceClient) CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...grpc.CallOption) (*CreateVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVersionResponse)
	err := c.cc.Invoke(ctx, MapCodeService_CreateVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) GetVersions(ctx context.Context, in *GetVersionsRequest, opts ...grpc.CallOption) (*GetVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVersionsResponse)
	err := c.cc.Invoke(ctx, MapCodeService_GetVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) GetActiveVersion(ctx context.Context, in *GetActiveVersionRequest, opts ...grpc.CallOption) (*GetActiveVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveVersionResponse)
	err := c.cc.Invoke(ctx, MapCodeService_GetActiveVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) SetActiveVersion(ctx context.Context, in *SetActiveVersionRequest, opts ...grpc.CallOption) (*SetActiveVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetActiveVersionResponse)
	err := c.cc.Invoke(ctx, MapCodeService_SetActiveVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) DeleteVersion(ctx context.Context, in *DeleteVersionRequest, opts ...grpc.CallOption) (*DeleteVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteVersionResponse)
	err := c.cc.Invoke(ctx, MapCodeService_DeleteVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) TranslateCode(ctx context.Context, in *TranslateCodeRequest, opts ...grpc.CallOption) (*TranslateCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TranslateCodeResponse)
	err := c.cc.Invoke(ctx, MapCodeService_TranslateCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) TranslateCodes(ctx context.Context, in *TranslateCodesRequest, opts ...grpc.CallOption) (*TranslateCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TranslateCodesResponse)
	err := c.cc.Invoke(ctx, MapCodeService_TranslateCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) GetHierarchyNavigation(ctx context.Context, in *GetHierarchyNavigationRequest, opts ...grpc.CallOption) (*GetHierarchyNavigationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHierarchyNavigationResponse)
	err := c.cc.Invoke(ctx, MapCodeService_GetHierarchyNavigation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) GetStorageInfo(ctx context.Context, in *GetStorageInfoRequest, opts ...grpc.CallOption) (*GetStorageInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStorageInfoResponse)
	err := c.cc.Invoke(ctx, MapCodeService_GetStorageInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapCodeServiceClient) GetMapCodeConfig(ctx context.Context, in *GetMapCodeConfigRequest, opts ...grpc.CallOption) (*GetMapCodeConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMapCodeConfigResponse)
	err := c.cc.Invoke(ctx, MapCodeService_GetMapCodeConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapCodeServiceServer is the server API for MapCodeService service.
// All implementations must embed UnimplementedMapCodeServiceServer
// for forward compatibility.
//
// MapCode Management Service
type MapCodeServiceServer interface {
	// Version Management
	CreateVersion(context.Context, *CreateVersionRequest) (*CreateVersionResponse, error)
	GetVersions(context.Context, *GetVersionsRequest) (*GetVersionsResponse, error)
	GetActiveVersion(context.Context, *GetActiveVersionRequest) (*GetActiveVersionResponse, error)
	SetActiveVersion(context.Context, *SetActiveVersionRequest) (*SetActiveVersionResponse, error)
	DeleteVersion(context.Context, *DeleteVersionRequest) (*DeleteVersionResponse, error)
	// Translation Services
	TranslateCode(context.Context, *TranslateCodeRequest) (*TranslateCodeResponse, error)
	TranslateCodes(context.Context, *TranslateCodesRequest) (*TranslateCodesResponse, error)
	GetHierarchyNavigation(context.Context, *GetHierarchyNavigationRequest) (*GetHierarchyNavigationResponse, error)
	// Storage Management
	GetStorageInfo(context.Context, *GetStorageInfoRequest) (*GetStorageInfoResponse, error)
	// Configuration Access
	GetMapCodeConfig(context.Context, *GetMapCodeConfigRequest) (*GetMapCodeConfigResponse, error)
	mustEmbedUnimplementedMapCodeServiceServer()
}

// UnimplementedMapCodeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMapCodeServiceServer struct{}

func (UnimplementedMapCodeServiceServer) CreateVersion(context.Context, *CreateVersionRequest) (*CreateVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVersion not implemented")
}
func (UnimplementedMapCodeServiceServer) GetVersions(context.Context, *GetVersionsRequest) (*GetVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersions not implemented")
}
func (UnimplementedMapCodeServiceServer) GetActiveVersion(context.Context, *GetActiveVersionRequest) (*GetActiveVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveVersion not implemented")
}
func (UnimplementedMapCodeServiceServer) SetActiveVersion(context.Context, *SetActiveVersionRequest) (*SetActiveVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetActiveVersion not implemented")
}
func (UnimplementedMapCodeServiceServer) DeleteVersion(context.Context, *DeleteVersionRequest) (*DeleteVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVersion not implemented")
}
func (UnimplementedMapCodeServiceServer) TranslateCode(context.Context, *TranslateCodeRequest) (*TranslateCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TranslateCode not implemented")
}
func (UnimplementedMapCodeServiceServer) TranslateCodes(context.Context, *TranslateCodesRequest) (*TranslateCodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TranslateCodes not implemented")
}
func (UnimplementedMapCodeServiceServer) GetHierarchyNavigation(context.Context, *GetHierarchyNavigationRequest) (*GetHierarchyNavigationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHierarchyNavigation not implemented")
}
func (UnimplementedMapCodeServiceServer) GetStorageInfo(context.Context, *GetStorageInfoRequest) (*GetStorageInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageInfo not implemented")
}
func (UnimplementedMapCodeServiceServer) GetMapCodeConfig(context.Context, *GetMapCodeConfigRequest) (*GetMapCodeConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMapCodeConfig not implemented")
}
func (UnimplementedMapCodeServiceServer) mustEmbedUnimplementedMapCodeServiceServer() {}
func (UnimplementedMapCodeServiceServer) testEmbeddedByValue()                        {}

// UnsafeMapCodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapCodeServiceServer will
// result in compilation errors.
type UnsafeMapCodeServiceServer interface {
	mustEmbedUnimplementedMapCodeServiceServer()
}

func RegisterMapCodeServiceServer(s grpc.ServiceRegistrar, srv MapCodeServiceServer) {
	// If the following call pancis, it indicates UnimplementedMapCodeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MapCodeService_ServiceDesc, srv)
}

func _MapCodeService_CreateVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).CreateVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_CreateVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).CreateVersion(ctx, req.(*CreateVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_GetVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).GetVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_GetVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).GetVersions(ctx, req.(*GetVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_GetActiveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).GetActiveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_GetActiveVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).GetActiveVersion(ctx, req.(*GetActiveVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_SetActiveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetActiveVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).SetActiveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_SetActiveVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).SetActiveVersion(ctx, req.(*SetActiveVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_DeleteVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).DeleteVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_DeleteVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).DeleteVersion(ctx, req.(*DeleteVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_TranslateCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TranslateCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).TranslateCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_TranslateCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).TranslateCode(ctx, req.(*TranslateCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_TranslateCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TranslateCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).TranslateCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_TranslateCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).TranslateCodes(ctx, req.(*TranslateCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_GetHierarchyNavigation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHierarchyNavigationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).GetHierarchyNavigation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_GetHierarchyNavigation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).GetHierarchyNavigation(ctx, req.(*GetHierarchyNavigationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_GetStorageInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).GetStorageInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_GetStorageInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).GetStorageInfo(ctx, req.(*GetStorageInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MapCodeService_GetMapCodeConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMapCodeConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapCodeServiceServer).GetMapCodeConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MapCodeService_GetMapCodeConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapCodeServiceServer).GetMapCodeConfig(ctx, req.(*GetMapCodeConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MapCodeService_ServiceDesc is the grpc.ServiceDesc for MapCodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MapCodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.MapCodeService",
	HandlerType: (*MapCodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVersion",
			Handler:    _MapCodeService_CreateVersion_Handler,
		},
		{
			MethodName: "GetVersions",
			Handler:    _MapCodeService_GetVersions_Handler,
		},
		{
			MethodName: "GetActiveVersion",
			Handler:    _MapCodeService_GetActiveVersion_Handler,
		},
		{
			MethodName: "SetActiveVersion",
			Handler:    _MapCodeService_SetActiveVersion_Handler,
		},
		{
			MethodName: "DeleteVersion",
			Handler:    _MapCodeService_DeleteVersion_Handler,
		},
		{
			MethodName: "TranslateCode",
			Handler:    _MapCodeService_TranslateCode_Handler,
		},
		{
			MethodName: "TranslateCodes",
			Handler:    _MapCodeService_TranslateCodes_Handler,
		},
		{
			MethodName: "GetHierarchyNavigation",
			Handler:    _MapCodeService_GetHierarchyNavigation_Handler,
		},
		{
			MethodName: "GetStorageInfo",
			Handler:    _MapCodeService_GetStorageInfo_Handler,
		},
		{
			MethodName: "GetMapCodeConfig",
			Handler:    _MapCodeService_GetMapCodeConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/mapcode.proto",
}
